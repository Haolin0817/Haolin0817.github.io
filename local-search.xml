<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Linux运行hadoop提示无权限</title>
    <link href="/2020/05/15/Linux%E8%BF%90%E8%A1%8Chadoop%E6%8F%90%E7%A4%BA%E6%97%A0%E6%9D%83%E9%99%90/"/>
    <url>/2020/05/15/Linux%E8%BF%90%E8%A1%8Chadoop%E6%8F%90%E7%A4%BA%E6%97%A0%E6%9D%83%E9%99%90/</url>
    
    <content type="html"><![CDATA[<h2 id="Linux运行hadoop提示无权限"><a href="#Linux运行hadoop提示无权限" class="headerlink" title="Linux运行hadoop提示无权限"></a><p align="center">Linux运行hadoop提示无权限</p></h2><p align="right">记录人：霖雨成思<blockquote><p>root账户执行指令：chown -R hadoop:hadoop /opt/modules/hadoop-2.7.6(hadoop解压目录)就可以了</p></blockquote></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>OGNL</title>
    <link href="/2020/05/15/OGNL/"/>
    <url>/2020/05/15/OGNL/</url>
    
    <content type="html"><![CDATA[<h2 id="第一个Struts2程序"><a href="#第一个Struts2程序" class="headerlink" title="第一个Struts2程序"></a><p align="center">第一个Struts2程序</p></h2><p align="right">记录人：霖雨成思</p><h4 id="什么是OGNL"><a href="#什么是OGNL" class="headerlink" title="什么是OGNL"></a>什么是OGNL</h4><blockquote><p>Object Graph Navigation Language<br>开源项目，取代页面中Java脚本，简化数据访问<br>和EL同属于表达式语言，但功能更为强大</p></blockquote><h4 id="OGNL在Struts2中做的两件事"><a href="#OGNL在Struts2中做的两件事" class="headerlink" title="OGNL在Struts2中做的两件事"></a>OGNL在Struts2中做的两件事</h4><blockquote><h5 id="表达式语言"><a href="#表达式语言" class="headerlink" title="表达式语言"></a>表达式语言</h5><ul><li>将表单或Struts2标签与特定的Java数据绑定起来，用来数据移入、移出框架<h5 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h5><ul><li>数据进入和流出框架，在页面数据的字符串类型和Java数据类型之间进行转换</li></ul></li></ul></blockquote><h4 id="OGNL融入Struts2"><a href="#OGNL融入Struts2" class="headerlink" title="OGNL融入Struts2"></a>OGNL融入Struts2</h4><h5 id="数据流入"><a href="#数据流入" class="headerlink" title="数据流入"></a>数据流入</h5><h5 id="输入流出"><a href="#输入流出" class="headerlink" title="输入流出"></a>输入流出</h5><p><img src="/2020/05/15/OGNL/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200515095332.png" srcset="/img/loading.gif" alt="Alt text"></p><h4 id="值栈（ValueStack）"><a href="#值栈（ValueStack）" class="headerlink" title="值栈（ValueStack）"></a>值栈（ValueStack）</h4><h5 id="由Struts2框架创建的存储区域，具有栈的特点"><a href="#由Struts2框架创建的存储区域，具有栈的特点" class="headerlink" title="由Struts2框架创建的存储区域，具有栈的特点"></a>由Struts2框架创建的存储区域，具有栈的特点</h5><h5 id="Action的实例会被存放到值栈中"><a href="#Action的实例会被存放到值栈中" class="headerlink" title="Action的实例会被存放到值栈中"></a>Action的实例会被存放到值栈中</h5><h4 id="OGNL访问值栈"><a href="#OGNL访问值栈" class="headerlink" title="OGNL访问值栈"></a>OGNL访问值栈</h4><h5 id="按照从上到下的顺序"><a href="#按照从上到下的顺序" class="headerlink" title="按照从上到下的顺序"></a>按照<strong>从上到下</strong>的顺序</h5><h5 id="靠近栈顶的同名属性会被读取"><a href="#靠近栈顶的同名属性会被读取" class="headerlink" title="靠近栈顶的同名属性会被读取"></a>靠近栈顶的同名属性会被读取</h5><h4 id="内置类型转换器"><a href="#内置类型转换器" class="headerlink" title="内置类型转换器"></a>内置类型转换器</h4><h5 id="Struts2提供了多种内置类型转换器，自动对客户端传来的数据进行类型转换"><a href="#Struts2提供了多种内置类型转换器，自动对客户端传来的数据进行类型转换" class="headerlink" title="Struts2提供了多种内置类型转换器，自动对客户端传来的数据进行类型转换"></a>Struts2提供了多种内置类型转换器，自动对客户端传来的数据进行类型转换</h5><p><img src="/2020/05/15/OGNL/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200515095333.png" srcset="/img/loading.gif" alt="Alt text"><br><img src="/2020/05/15/OGNL/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_202005150953331.png" srcset="/img/loading.gif" alt="Alt text"><br><img src="/2020/05/15/OGNL/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_202005150953332.png" srcset="/img/loading.gif" alt="Alt text"><br><img src="/2020/05/15/OGNL/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_202005150953333.png" srcset="/img/loading.gif" alt="Alt text"></p><h4 id="配置自定义类型转换器"><a href="#配置自定义类型转换器" class="headerlink" title="配置自定义类型转换器"></a>配置自定义类型转换器</h4><h5 id="应用于全局范围的类型转换器"><a href="#应用于全局范围的类型转换器" class="headerlink" title="应用于全局范围的类型转换器"></a>应用于全局范围的类型转换器</h5><h6 id="在src目录下创建xwork-conversion-properties"><a href="#在src目录下创建xwork-conversion-properties" class="headerlink" title="在src目录下创建xwork-conversion.properties"></a>在src目录下创建xwork-conversion.properties</h6><p>[转换类全名=类型转换器全名]</p><h5 id="应用于特定的类型转换器"><a href="#应用于特定的类型转换器" class="headerlink" title="应用于特定的类型转换器"></a>应用于特定的类型转换器</h5><h6 id="在特定类的相同目录下创建一个名为ClassName-conversion-properties的属性文件"><a href="#在特定类的相同目录下创建一个名为ClassName-conversion-properties的属性文件" class="headerlink" title="在特定类的相同目录下创建一个名为ClassName-conversion.properties的属性文件"></a>在特定类的相同目录下创建一个名为ClassName-conversion.properties的属性文件</h6><p>[特定类的属性名=类型转换器类全名]</p><h4 id="处理类型转换错误"><a href="#处理类型转换错误" class="headerlink" title="处理类型转换错误"></a>处理类型转换错误</h4><p><img src="/2020/05/15/OGNL/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_202005150953334.png" srcset="/img/loading.gif" alt="Alt text"></p><h5 id="向用户输出类型转换错误的前提条件"><a href="#向用户输出类型转换错误的前提条件" class="headerlink" title="向用户输出类型转换错误的前提条件"></a>向用户输出类型转换错误的前提条件</h5><h6 id="启动StrutsConversionErrorInterceptor拦截器"><a href="#启动StrutsConversionErrorInterceptor拦截器" class="headerlink" title="启动StrutsConversionErrorInterceptor拦截器"></a>启动StrutsConversionErrorInterceptor拦截器</h6><ul><li>拦截器已经包含在defaultStack拦截器栈中<h5 id="Action要继承ActionSupport类"><a href="#Action要继承ActionSupport类" class="headerlink" title="Action要继承ActionSupport类"></a>Action要继承ActionSupport类</h5></li><li>实质是实现ValidationAware接口<h5 id="配置input结果映射"><a href="#配置input结果映射" class="headerlink" title="配置input结果映射"></a>配置input结果映射</h5><h5 id="页面使用Struts2表单标签或-lt-s-fielderror-gt-标签"><a href="#页面使用Struts2表单标签或-lt-s-fielderror-gt-标签" class="headerlink" title="页面使用Struts2表单标签或&lt;s:fielderror&gt;标签"></a>页面使用Struts2表单标签或<code>&lt;s:fielderror&gt;</code>标签</h5></li><li>Struts2表单标签内嵌了输出错误信息功能</li><li>普通HTML标签需使用<code>&lt;s:fielderror&gt;</code>标签输出转换错误<br><img src="/2020/05/15/OGNL/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_202005150953335.png" srcset="/img/loading.gif" alt="Alt text"><br><img src="/2020/05/15/OGNL/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_202005150953336.png" srcset="/img/loading.gif" alt="Alt text"><h4 id="OGNL-表达式注意事项"><a href="#OGNL-表达式注意事项" class="headerlink" title="OGNL 表达式注意事项"></a>OGNL 表达式注意事项</h4><h5 id="访问Bean的属性"><a href="#访问Bean的属性" class="headerlink" title="访问Bean的属性"></a>访问Bean的属性</h5><h6 id="Bean的类型必须遵循JavaBean规范"><a href="#Bean的类型必须遵循JavaBean规范" class="headerlink" title="Bean的类型必须遵循JavaBean规范"></a>Bean的类型必须遵循JavaBean规范</h6></li><li>必须具有无参构造<h5 id="访问集合对象"><a href="#访问集合对象" class="headerlink" title="访问集合对象"></a>访问集合对象</h5><h6 id="可以使用属性名-index-的方式访问"><a href="#可以使用属性名-index-的方式访问" class="headerlink" title="可以使用属性名[index]的方式访问"></a>可以使用属性名[index]的方式访问</h6></li><li>列表、数组<h6 id="可以使用属性名-key-的方式访问"><a href="#可以使用属性名-key-的方式访问" class="headerlink" title="可以使用属性名[key]的方式访问"></a>可以使用属性名[key]的方式访问</h6></li><li>Map对象<h6 id="使用size或者length获取集合长度"><a href="#使用size或者length获取集合长度" class="headerlink" title="使用size或者length获取集合长度"></a>使用size或者length获取集合长度</h6></li></ul><h5 id="访问JavaBean"><a href="#访问JavaBean" class="headerlink" title="访问JavaBean"></a>访问JavaBean</h5><p><img src="/2020/05/15/OGNL/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_202005150953337.png" srcset="/img/loading.gif" alt="Alt text"></p><h5 id="定义列表"><a href="#定义列表" class="headerlink" title="定义列表"></a>定义列表</h5><p><img src="/2020/05/15/OGNL/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_202005150953338.png" srcset="/img/loading.gif" alt="Alt text"></p><h5 id="定义数组"><a href="#定义数组" class="headerlink" title="定义数组"></a>定义数组</h5><p><img src="/2020/05/15/OGNL/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_202005150953339.png" srcset="/img/loading.gif" alt="Alt text"></p><h5 id="定义Map"><a href="#定义Map" class="headerlink" title="定义Map"></a>定义Map</h5><p><img src="/2020/05/15/OGNL/aa6cfe8d1cadb382378bfa3011357f2.png" srcset="/img/loading.gif" alt="Alt text"></p><h4 id="Struts2下使用OGNL"><a href="#Struts2下使用OGNL" class="headerlink" title="Struts2下使用OGNL"></a>Struts2下使用OGNL</h4><h5 id="访问非值栈对象"><a href="#访问非值栈对象" class="headerlink" title="访问非值栈对象"></a>访问非值栈对象</h5><p><img src="/2020/05/15/OGNL/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_2020051509533310.png" srcset="/img/loading.gif" alt="Alt text"><br><img src="/2020/05/15/OGNL/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_2020051509533311.png" srcset="/img/loading.gif" alt="Alt text"></p><pre><code class="xml">&lt;s:set name=&quot;age&quot; value=&quot;10&quot; scope=&quot;request&quot;/&gt;&lt;s:set name=&quot;username&quot; value=&quot;&#39;Jason&#39;&quot; scope=&quot;session&quot;/&gt;&lt;s:set name=&quot;count&quot; value=&quot;5&quot; scope=&quot;application&quot;/&gt;        #request.age:&lt;s:property value=&quot;#request.age&quot;/&gt;&lt;br/&gt;#session.username:&lt;s:property value=&quot;#session.username&quot;/&gt;&lt;br/&gt;#application.count:&lt;s:property value=&quot;#application.count&quot;/&gt;&lt;br/&gt;#attr.count:&lt;s:property value=&quot;#attr.count&quot; /&gt;&lt;br /&gt;    &lt;s:set name=&quot;country1&quot; value=&quot;China&quot;/&gt;    &lt;s:set name=&quot;country2&quot; value=&quot;&#39;China&#39;&quot;/&gt;#country1:&lt;s:property value=&quot;#country1&quot;/&gt;&lt;br/&gt;#country2:&lt;s:property value=&quot;#country2&quot;/&gt;&lt;br/&gt;    #request.country2:&lt;s:property value=&quot;#request.country2&quot;/&gt;&lt;br/&gt;</code></pre><h4 id="使用-lt-s-debug-gt-查看数据"><a href="#使用-lt-s-debug-gt-查看数据" class="headerlink" title="使用&lt;s:debug/&gt;查看数据"></a>使用<code>&lt;s:debug/&gt;</code>查看数据</h4><h5 id="ActionContext的组成"><a href="#ActionContext的组成" class="headerlink" title="ActionContext的组成"></a>ActionContext的组成</h5><ul><li>值栈-ValueStack</li><li>非值栈-Stack Context<h4 id="Struts2标签的属性类型"><a href="#Struts2标签的属性类型" class="headerlink" title="Struts2标签的属性类型"></a>Struts2标签的属性类型</h4><img src="/2020/05/15/OGNL/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_2020051509533312.png" srcset="/img/loading.gif" alt="Alt text"><h4 id="URL标签"><a href="#URL标签" class="headerlink" title="URL标签"></a>URL标签</h4><img src="/2020/05/15/OGNL/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_2020051509533312.png" srcset="/img/loading.gif" alt="Alt text"><h4 id="日期标签"><a href="#日期标签" class="headerlink" title="日期标签"></a>日期标签</h4><img src="/2020/05/15/OGNL/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_2020051509533313.png" srcset="/img/loading.gif" alt="Alt text"></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote><p>Struts 2提供了非常强大的类型转换功能，提供了多种内置类型转换器，也支持开发自定义类型转换器<br>Struts 2框架使用OGNL作为默认的表达式语言<br>ActionContext中包含多个对象。如果使用OGNL访问根对象，可直接书写对象的属性，而要使用其他对象必须使用“#key”前缀来访问<br>使用Struts 2日期标签可以实现日期输出的格式化显示，使用URL标签可以构建一个超链接<br><img src="/2020/05/15/OGNL/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_2020051509533314.png" srcset="/img/loading.gif" alt="Alt text"></p></blockquote><blockquote><p>本文根据哈尔滨华育兴业教师欧阳广靖老师的课记录</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Strust2入门</title>
    <link href="/2020/04/28/Strust2%E5%85%A5%E9%97%A8/"/>
    <url>/2020/04/28/Strust2%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="第一个Struts2程序"><a href="#第一个Struts2程序" class="headerlink" title="第一个Struts2程序"></a><p align="center">第一个Struts2程序</p></h2><p align="right">记录人：霖雨成思</p><h4 id="加载Struts2类库（导包）"><a href="#加载Struts2类库（导包）" class="headerlink" title="加载Struts2类库（导包）"></a>加载Struts2类库（导包）</h4><p><img src="/2020/04/28/Strust2%E5%85%A5%E9%97%A8/jar1.png" srcset="/img/loading.gif" alt="Alt text"><br><img src="/2020/04/28/Strust2%E5%85%A5%E9%97%A8/jar2.png" srcset="/img/loading.gif" alt="Alt text"></p><h4 id="配置web-xml文件"><a href="#配置web-xml文件" class="headerlink" title="配置web.xml文件"></a>配置web.xml文件</h4><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:web=&quot;http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; version=&quot;3.0&quot;&gt;  &lt;filter&gt;    &lt;filter-name&gt;struts2&lt;/filter-name&gt;    &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;  &lt;/filter&gt;  &lt;filter-mapping&gt;    &lt;filter-name&gt;struts2&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;!--将全部请求定位到指定的Struts2过滤器中--&gt;  &lt;/filter-mapping&gt;  &lt;welcome-file-list&gt;    &lt;welcome-file&gt;/helloWorld.jsp&lt;/welcome-file&gt;  &lt;/welcome-file-list&gt;&lt;/web-app&gt;</code></pre><h4 id="开发视图层页面（前台）"><a href="#开发视图层页面（前台）" class="headerlink" title="开发视图层页面（前台）"></a>开发视图层页面（前台）</h4><p>编写输出页面helloWorld.jsp</p><pre><code class="jsp">&lt;body&gt;${message}&lt;br&gt;&lt;!-- 与定影的action文件属性一致 --&gt;&lt;!-- 与Struts.xml配置文件中，action标签的name值一致 --&gt;&lt;form action=&quot;helloWorld.action&quot; method=&quot;post&quot;&gt;&lt;!-- input标签的name值与action的属性名一致 --&gt;用户名:&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt;密    码:&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;</code></pre><h4 id="开发控制层Action"><a href="#开发控制层Action" class="headerlink" title="开发控制层Action"></a>开发控制层Action</h4><p>编写HelloWorldAction</p><pre><code class="java">public class HelloWorldAction implements Action {    // 用户输入的姓名    private String name = &quot;&quot;;    // 向用户显示的信息    private String message = &quot;&quot;;    public String execute() {        // 根据用户输入的姓名,进行&quot;Hello,XXXX!&quot;的封装        this.setMessage(&quot;Hello,&quot;+this.getName()+&quot;!&quot;);        // 处理完毕,返回导航结果的逻辑名        return &quot;success&quot;;    }    ……    //省略setter、getter方法}或import com.opensymphony.xwork2.Action;public class HelloStrutsAction implements Action{    //获取页面数据    private String username;    private String password;    //传值到页面的数据    private String message;    @Override    public String execute() throws Exception {        if(username.equals(&quot;admin&quot;)&amp;&amp;password.equals(&quot;123456&quot;)){            message=username+&quot;,欢迎您&quot;;        }else{            message = username+&quot;,您的用户名或密码不正确&quot;;        }        return &quot;success&quot;;//与Struts.xml文件的action的result标签的name一致    }    ……    //省略setter、getter方法</code></pre><h4 id="配置struts-xml文件"><a href="#配置struts-xml文件" class="headerlink" title="配置struts.xml文件"></a>配置struts.xml文件</h4><pre><code>&lt;struts&gt;    &lt;!-- 创建一个default包，继承自Struts2的struts-default包 --&gt;    &lt;package name=&quot;default&quot; namespace=&quot;/&quot; extends=&quot;struts-default&quot;&gt;        &lt;!-- 接收处理用户的/helloWorld.action请求 ，并根据返回结果，完成 跳转            name与页面的 请求地址一致，class是处理的action类全路径--&gt;        &lt;action name=&quot;helloWorld&quot; class=&quot;com.hib.action.HelloStrutsAction&quot;&gt;            &lt;!-- 结果为&quot;helloWorld&quot;时，跳转至helloWorld.jsp页面 --&gt;            &lt;result name=&quot;success&quot;&gt;helloWorld.jsp&lt;/result&gt;        &lt;/action&gt;        &lt;action name=&quot;login&quot; class=&quot;com.hib.action.LoginAction&quot;&gt;            &lt;!-- 结果为&quot;success&quot;时，跳转至success.jsp页面 --&gt;            &lt;result name=&quot;success&quot;&gt;enter.jsp&lt;/result&gt;            &lt;!-- 结果为&quot;error&quot;时，跳转至login.jsp页面 --&gt;            &lt;result name=&quot;faile&quot;&gt;login.jsp&lt;/result&gt;            &lt;result name=&quot;input&quot;&gt;login.jsp&lt;/result&gt;        &lt;/action&gt;    &lt;/package&gt;&lt;/struts&gt;</code></pre><p><img src="/2020/04/28/Strust2%E5%85%A5%E9%97%A8/Struts.xml.png" srcset="/img/loading.gif" alt="Alt text"></p><p>####部署、运行项目</p><p>####如果登录成功，如果使用session保存用户信息</p><p>Struts2访问Servlet API的方式</p><ul><li>与Servlet API解耦的访问方式</li></ul><p><img src="/2020/04/28/Strust2%E5%85%A5%E9%97%A8/jieou.png" srcset="/img/loading.gif" alt="Alt text"></p><p>页面显示<br><img src="/2020/04/28/Strust2%E5%85%A5%E9%97%A8/xianshi.png" srcset="/img/loading.gif" alt="Alt text"></p><ul><li>与Servlet API耦合的访问方式</li></ul><p><img src="/2020/04/28/Strust2%E5%85%A5%E9%97%A8/ouhe.png" srcset="/img/loading.gif" alt="Alt text"></p><h4 id="如何对用户登录添加表单验证功能"><a href="#如何对用户登录添加表单验证功能" class="headerlink" title="如何对用户登录添加表单验证功能"></a>如何对用户登录添加表单验证功能</h4><blockquote><p>Struts2提供了数据验证机制</p></blockquote><ul><li>继承ActionSupport类来完成Action开发</li><li>ActionSupport类不仅对Action接口进行简单实现，同时还增加了验证、本地化等支持</li></ul><p><img src="/2020/04/28/Strust2%E5%85%A5%E9%97%A8/xiugai.png" srcset="/img/loading.gif" alt="Alt text"></p><h4 id="如何将Action的错误信息在页面输出？"><a href="#如何将Action的错误信息在页面输出？" class="headerlink" title="如何将Action的错误信息在页面输出？"></a>如何将Action的错误信息在页面输出？</h4><blockquote><p>使用Struts2提供的标签来完成<br>Struts2标签分为UI标签和通用标签</p></blockquote><pre><code>&lt;%@ taglib prefix=&quot;s&quot; uri=&quot;/struts-tags&quot;%&gt;![Alt text](./1588059221987.png) &lt;!--需要在页面中引入Struts2的标签库--&gt;</code></pre><h5 id="常用表单标签"><a href="#常用表单标签" class="headerlink" title="常用表单标签"></a>常用表单标签</h5><p><img src="/2020/04/28/Strust2%E5%85%A5%E9%97%A8/biaodan1.png" srcset="/img/loading.gif" alt="Alt text"></p><h5 id="常用非表单标签"><a href="#常用非表单标签" class="headerlink" title="常用非表单标签"></a>常用非表单标签</h5><p><img src="/2020/04/28/Strust2%E5%85%A5%E9%97%A8/biaodan2.png" srcset="/img/loading.gif" alt="Alt text"></p><h4 id="修改jsp页面"><a href="#修改jsp页面" class="headerlink" title="修改jsp页面"></a>修改jsp页面</h4><p><img src="/2020/04/28/Strust2%E5%85%A5%E9%97%A8/xiugai2.png" srcset="/img/loading.gif" alt="Alt text"></p><h4 id="使用Struts2标签是否可以在页面中实现逻辑控制？"><a href="#使用Struts2标签是否可以在页面中实现逻辑控制？" class="headerlink" title="使用Struts2标签是否可以在页面中实现逻辑控制？"></a>使用Struts2标签是否可以在页面中实现逻辑控制？</h4><blockquote><p>使用Struts2的通用标签</p></blockquote><ul><li>条件判断标签</li><li>迭代标签</li></ul><h5 id="常用通用标签"><a href="#常用通用标签" class="headerlink" title="常用通用标签"></a>常用通用标签</h5><p><img src="/2020/04/28/Strust2%E5%85%A5%E9%97%A8/changyongtongyong.png" srcset="/img/loading.gif" alt="Alt text"></p><p><img src="/2020/04/28/Strust2%E5%85%A5%E9%97%A8/tiaojianpanduan.png" srcset="/img/loading.gif" alt="Alt text"></p><p><img src="/2020/04/28/Strust2%E5%85%A5%E9%97%A8/iterator.png" srcset="/img/loading.gif" alt="Alt text"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="/2020/04/28/Strust2%E5%85%A5%E9%97%A8/zongjie.png" srcset="/img/loading.gif" alt="Alt text"></p><blockquote><p>本文根据哈尔滨华育兴业教师欧阳广靖老师的课记录</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>在电脑中建立虚拟域名并绑定项目</title>
    <link href="/2020/04/12/%E5%9C%A8%E7%94%B5%E8%84%91%E4%B8%AD%E5%BB%BA%E7%AB%8B%E8%99%9A%E6%8B%9F%E5%9F%9F%E5%90%8D%E5%B9%B6%E7%BB%91%E5%AE%9A%E9%A1%B9%E7%9B%AE/"/>
    <url>/2020/04/12/%E5%9C%A8%E7%94%B5%E8%84%91%E4%B8%AD%E5%BB%BA%E7%AB%8B%E8%99%9A%E6%8B%9F%E5%9F%9F%E5%90%8D%E5%B9%B6%E7%BB%91%E5%AE%9A%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="在电脑中建立虚拟域名并绑定项目"><a href="#在电脑中建立虚拟域名并绑定项目" class="headerlink" title="在电脑中建立虚拟域名并绑定项目"></a><p align="center">在电脑中建立虚拟域名并绑定项目</p></h2><p align="right">记录人：霖雨成思</p><h4 id="Windows下使用Apache配置多域名的方法"><a href="#Windows下使用Apache配置多域名的方法" class="headerlink" title="Windows下使用Apache配置多域名的方法"></a>Windows下使用Apache配置多域名的方法</h4><p>1、修改C:\Windows\System32\drivers\etc目录下的hosts文件<br>127.0.0.1（本机）    shop.top（域名）</p><blockquote><p>“#代表注释”</p></blockquote><p>2、修改D:\phpStudy\Apache\conf (这个目录不固定）目录下的httpd.conf文件,去掉前面的#<br><img src="/2020/04/12/%E5%9C%A8%E7%94%B5%E8%84%91%E4%B8%AD%E5%BB%BA%E7%AB%8B%E8%99%9A%E6%8B%9F%E5%9F%9F%E5%90%8D%E5%B9%B6%E7%BB%91%E5%AE%9A%E9%A1%B9%E7%9B%AE/1.png" srcset="/img/loading.gif" alt="Alt text"></p><p>3、修改D:\phpStudy\Apache\extra (这个目录不固定）目录下的httpd-vhosts.conf文件,添加以下内容</p><pre><code>&lt;/VirtualHost&gt;&lt;VirtualHost *:80&gt; #如果更改默认端口号，则写更改后的端口DocumentRoot &quot;你的项目名&quot;   ServerName 你的域名  &lt;/VirtualHost&gt;</code></pre><p>4、重启服务器，访问域名，自然就回访问到你的项目</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hibernate简单配置——实现增删改查</title>
    <link href="/2020/04/04/Hibernate%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5-0/"/>
    <url>/2020/04/04/Hibernate%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5-0/</url>
    
    <content type="html"><![CDATA[<p align="center">hibernate简单配置——实现增删改查</p><p align="right">记录人：霖雨成思</p><p>2020年4月4日 清明节<br>写这篇博客之前想说<br>今天是清明节，为表达全国各族人民对抗击新冠肺炎疫情斗争牺牲烈士和逝世同胞的深切哀悼，国务院决定2020年4月4日举行全国性哀悼活动为表达全国各族人民对抗击新冠肺炎疫情斗争牺牲烈士和逝世同胞的深切哀悼，国务院决定2020年4月4日举行全国性哀悼活动<br>愿逝者安息，愿生者奋发，愿祖国昌盛</p><blockquote><p>hibernate极大的简化了JDBC繁琐的编码<br>对面向对象特性支持良好<br>可移植性好</p></blockquote><h3 id="hibernate的步骤使用"><a href="#hibernate的步骤使用" class="headerlink" title="hibernate的步骤使用"></a>hibernate的步骤使用</h3><ul><li>现在并部署jar文件</li><li>编写hibernate配置文件</li><li>创建持久化类和映射文件</li><li>使用hibernate API</li></ul><h3 id="部署jar文件"><a href="#部署jar文件" class="headerlink" title="部署jar文件"></a>部署jar文件</h3><h5 id="下载需要的jar文件"><a href="#下载需要的jar文件" class="headerlink" title="下载需要的jar文件"></a>下载需要的jar文件</h5><p>Hibernate的官方网站<a href="http://hibernate.org" target="_blank" rel="noopener">http://hibernate.org</a><br>托管网站<a href="https://sourceforge.net/projects/hibernate/files/" target="_blank" rel="noopener">https://sourceforge.net/projects/hibernate/files/</a><br>推荐下载：hibernate-distribution-3.6.10.Final-dist.zip</p><h5 id="部署jar文件-1"><a href="#部署jar文件-1" class="headerlink" title="部署jar文件"></a>部署jar文件</h5><p>hibernate3.jar<br>hibernate需要的相关jar文件<br>mysql数据库驱动jar文件</p><h3 id="编写hibernate配置文件-一般命名为hibernate-cfg-xml"><a href="#编写hibernate配置文件-一般命名为hibernate-cfg-xml" class="headerlink" title="编写hibernate配置文件(一般命名为hibernate.cfg.xml)"></a>编写hibernate配置文件(一般命名为hibernate.cfg.xml)</h3><pre><code class="xml">&lt;?xml version=&#39;1.0&#39; encoding=&#39;utf-8&#39;?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC    &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot;    &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;&lt;hibernate-configuration&gt;    &lt;session-factory&gt;        &lt;!-- 数据库URL:localhost是本机的地址，3306是MySQL默认端口号，house是数据库名 --&gt;        &lt;property name=&quot;connection.url&quot;&gt;            jdbc:mysql://localhost:3306/house        &lt;/property&gt;        &lt;!--  数据库用户  --&gt;        &lt;property name=&quot;connection.username&quot;&gt;root&lt;/property&gt;        &lt;!--  数据库用户密码  --&gt;        &lt;property name=&quot;connection.password&quot;&gt;root&lt;/property&gt;        &lt;!-- 数据库JDBC驱动   --&gt;        &lt;property name=&quot;connection.driver_class&quot;&gt;            com.mysql.jdbc.Driver        &lt;/property&gt;        &lt;!--  每个数据库都有其对应的Dialect以匹配其平台特性   hibernate根据平台写SQL  --&gt;        &lt;property name=&quot;dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;        &lt;!--  指定当前session范围和上下文   当提交以后session自动关闭--&gt;        &lt;property name=&quot;current_session_context_class&quot;&gt;thread&lt;/property&gt;        &lt;!--  是否将运行期生成的SQL输出到日志以供调试   --&gt;        &lt;property name=&quot;show_sql&quot;&gt;true&lt;/property&gt;        &lt;!--   是否格式化SQL   --&gt;        &lt;property name=&quot;format_sql&quot;&gt;true&lt;/property&gt;                &lt;!--    加载映射文件资源，资源包中间用/例如：dao/Users.hbm.xml   --&gt;        &lt;mapping resource=&quot;dao/Users.hbm.xml&quot;/&gt;    &lt;/session-factory&gt;&lt;/hibernate-configuration&gt;</code></pre><blockquote><p>我在向数据库输出中文内容时，出现乱码行为，在上边的配置文件中的数据库后边加上:</p></blockquote><pre><code>?Unicode=true&amp;amp;characterEncoding=GBK </code></pre><h3 id="创建持久化类和映射文件"><a href="#创建持久化类和映射文件" class="headerlink" title="创建持久化类和映射文件"></a>创建持久化类和映射文件</h3><pre><code class="java">public class Users {    //Users封装类    private int eid;    private String ename;    。。。省略getter和setter方法</code></pre><p>···</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC     &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;    &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping&gt;    &lt;!-- name是class的路径  table为表名（如果是关键字，用``括上  dynamic-update动态修改 --&gt;    &lt;!-- 映射文类和表，class中的class是实体类（持久化类）名字 --&gt;    &lt;class name=&quot;Users&quot; table=&quot;users&quot; dynamic-update=&quot;true&quot;&gt;        &lt;!-- name实体类属性名   column是表中的字段名  --&gt;        &lt;id name=&quot;eid&quot; type=&quot;java.lang.Integer&quot; column=&quot;id&quot; &gt;        &lt;!-- class自增，设置完后数据库可以不用设置自增 （主键生成策略）native为数据库中字段已设置自增--&gt;            &lt;generator class=&quot;assigned&quot;/&gt;        &lt;/id&gt;         &lt;!-- column数据库表里的列名 --&gt;        &lt;property name=&quot;ename&quot; type=&quot;java.lang.String&quot; column=&quot;name&quot;/&gt;    &lt;/class&gt;&lt;/hibernate-mapping&gt;</code></pre><p>注意：数据库使用主键生成器不要使用assigned</p><h3 id="使用hibernate-API"><a href="#使用hibernate-API" class="headerlink" title="使用hibernate API"></a>使用hibernate API</h3><pre><code class="java">import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.hibernate.cfg.Configuration;import org.junit.Test;public class Tests {    //开启事物    public static Session Trans(){        //读取xml文件                Configuration conf = new Configuration().configure();                //创建session工厂                SessionFactory sessionFactory = conf.buildSessionFactory();                //获取session                Session session = sessionFactory.getCurrentSession();                return session;    }    //添加方法    @Test    public void add(){        System.out.println(&quot;添加方法&quot;);        Session session = Tests.Trans();        //开启事物        Transaction trans = session.beginTransaction();        //实例化对象        Users u = new Users();//临时状态        u.setEid(3);        u.setEname(&quot;王五&quot;);        session.save(u);//持久状态        trans.commit();//提交    }    //删除方法    @Test    public void del(){        System.out.println(&quot;删除方法&quot;);        Session session = Tests.Trans();        Transaction trans = session.beginTransaction();        //实例化对象        Users u = new Users();//临时状态        u.setEid(3);        session.delete(u);        trans.commit();    }    //修改方法1：只修改写入的属性    @Test    public void update1(){        System.out.println(&quot;修改方法1&quot;);        Session session = Tests.Trans();        //开启事物        Transaction trans = session.beginTransaction();        Users u = (Users) session.get(Users.class, 1);//直接转换为持久态        u.setEname(&quot;张小三&quot;);        trans.commit();//提交的时候，如果u与数据库不一致，则执行update        System.out.println(u);//游离态    }     //修改方法2：全部修改，如果没写，则数据库对应属性为空    @Test    public void update2(){        System.out.println(&quot;修改方法2&quot;);        Session session = Tests.Trans();        Transaction trans = session.beginTransaction();        Users u = new Users();        u.setEid(2);        u.setTelephone(&quot;13222223333&quot;);        session.update(u);        trans.commit();    }    //修改方法3 :全部修改，如果没写，则数据库对应属性为空    @Test    public void update3(){        System.out.println(&quot;修改方法3&quot;);        Session session = Tests.Trans();        Transaction trans = session.beginTransaction();        Users u = new Users();        u.setEid(2);        u.setEname(&quot;李四&quot;);        session.merge(u);        trans.commit();    }    //修改方法4:全部修改 ，如果没写，则对应属性为空    @Test    public void update4(){        System.out.println(&quot;修改方法4&quot;);        Session session = Tests.Trans();        Transaction trans = session.beginTransaction();        Users u = new Users();        u.setEid(3);        u.setEname(&quot;王小五&quot;);        u.setTelephone(&quot;13299998888&quot;);        session.saveOrUpdate(u);        trans.commit();    }    //按主键查询load 如果没有记录则抛出异常        @Test        public void load(){            System.out.println(&quot;load查询&quot;);            Session session = Tests.Trans();            Transaction trans = session.beginTransaction();            //按主键查找数据,load:第一个参数时要查询的镖所对应的实体类，第二个参数时主键值            //当数据库有该主键值得记录时，返回一个对象            //当数据库中没有该主键值得记录时，抛出异常            Users u = (Users)session.load(Users.class, 1);            System.out.println(u);            //事物提交            trans.commit();        }        //按主键查询get 如果没有记录返回null        @Test        public void get(){            System.out.println(&quot;get查询&quot;);            Session session = Tests.Trans();            Transaction trans = session.beginTransaction();            //按主键查找数据,load:第一个参数时要查询的镖所对应的实体类，第二个参数时主键值            //当数据库有该主键值得记录时，返回一个对象            //当数据库中没有该主键值得记录时，返回null            Users u = (Users)session.get(Users.class, 1);            System.out.println(u);            //事物提交            trans.commit();        }}</code></pre><blockquote><p>SessionFactory无须反复创建</p></blockquote><hr><h4 id="附"><a href="#附" class="headerlink" title="附:"></a>附:</h4><h5 id="4种修改方法（-我在生成内容时，记录了修改的四种方法不同之处，仅表示个人见解，具体方法见上述代码）"><a href="#4种修改方法（-我在生成内容时，记录了修改的四种方法不同之处，仅表示个人见解，具体方法见上述代码）" class="headerlink" title="4种修改方法（ 我在生成内容时，记录了修改的四种方法不同之处，仅表示个人见解，具体方法见上述代码）"></a>4种修改方法（ 我在生成内容时，记录了修改的四种方法不同之处，仅表示个人见解，具体方法见上述代码）</h5><ul><li>方法1：只修改写入的属性 未写的属性不变</li><li>方法2：update 直接修改全部的属性 如果没写 则数据库对应属性为空</li><li>方法3：merge 全部修改 如果没写 则数据库对应属性为空（与方法2不同的是，merge方法先select一遍）</li><li>方法4：有则修改 无则保存 全部修改 如果没写 则数据库对应属性为空 与方法3一致，修改之前先select一遍</li></ul><h5 id="2种查询方法（load、get）"><a href="#2种查询方法（load、get）" class="headerlink" title="2种查询方法（load、get）"></a>2种查询方法（load、get）</h5><p>代码见上述<br>-Object get（Class clazz,Serializable id）若数据不存在，返回null<br>-Object load（Class clazz，Serializable id）若数据不存在，使用时抛出ObjectNotFoundException</p><h5 id="hibernate中Java对象的三种状态"><a href="#hibernate中Java对象的三种状态" class="headerlink" title="hibernate中Java对象的三种状态"></a>hibernate中Java对象的三种状态</h5><ul><li>瞬时状态（Transient）</li><li>持久状态（Persistent）</li><li>游离状态（Detached）</li></ul><p><img src="/2020/04/04/Hibernate%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5-0/29bd6dc17a3dcd8c3b44326ddd469da.png" srcset="/img/loading.gif" alt="Alt text"></p><p><img src="/2020/04/04/Hibernate%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5-0/2.png" srcset="/img/loading.gif" alt="Alt text"></p><h5 id><a href="#" class="headerlink" title></a></h5><p>最后附两张总结图片<br><img src="/2020/04/04/Hibernate%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5-0/43ecc9704a7166ac984f0122c270122.png" srcset="/img/loading.gif" alt="Alt text"><br><img src="/2020/04/04/Hibernate%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5-0/cde213aa384bd76f1c33fc83283ce76.png" srcset="/img/loading.gif" alt="Alt text"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux命令——系统信息类命令</title>
    <link href="/2020/03/24/Linux%E5%91%BD%E4%BB%A4%E2%80%94%E2%80%94%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E7%B1%BB%E5%91%BD%E4%BB%A4/"/>
    <url>/2020/03/24/Linux%E5%91%BD%E4%BB%A4%E2%80%94%E2%80%94%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E7%B1%BB%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="Linux命令-系统信息类命令"><a href="#Linux命令-系统信息类命令" class="headerlink" title="Linux命令-系统信息类命令"></a><p align="center">Linux命令-系统信息类命令</p></h2><p align="right">记录人：霖雨成思</p><h3 id="系统信息类命令"><a href="#系统信息类命令" class="headerlink" title="系统信息类命令"></a>系统信息类命令</h3><p>dmesg:作用是用来显示系统各种硬件的信息<br>df:显示磁盘中每个分区的空间使用情况（加上-h，页面会更直观）<br>du命令：列出当前目录下的每个子目录使用过的磁盘情况（加上-h，页面会更直观）<br>free:查看内存以及交换分区的使用情况（swap是Linux中的一个交换分区，相当于虚拟内存）<br>date：显示系统当前的日期和时间（不带参数）<br>cal（calendar）:默认会输出本月的月历<br>clock：获取从计算机硬件获取时间</p><h3 id="进程管理命令"><a href="#进程管理命令" class="headerlink" title="进程管理命令"></a>进程管理命令</h3><p>ps(process state):默认终端下默认用户的进程<br>终止进程:ps -a获取进程号，kill (参数-9 终止kill无法直接终止的进程)进程号 命令终止<br>renice:root用户修改进程优先级 用法：renice 优先级 进程号 （NI值修改后，系统会更改PRI值）<br>nice:生成一个进程的同时可以设定优先级 用法：nice -优先级 进程命令<br>top:实时监控系统的状态，默认情况下，每5秒钟刷新一次</p><h3 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h3><p>clear:清屏<br>uname:显示系统信息<br>man(manual):查看命令的使用手册<br>shutdown:root用户关机，使用必须带参数(-h now 立即关闭)<br>poweroff:和shutdown -h now 等效<br>reboot:重启系统<br>alias:起命令的别名 取消:unalias 如果有空格，用双引号将整条命令引起来<br>history:查看最近使用的命令记录(环境变量默认最多1000条)</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux命令——文件目录类命令</title>
    <link href="/2020/03/19/Linux%E5%91%BD%E4%BB%A4%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%B1%BB%E5%91%BD%E4%BB%A4/"/>
    <url>/2020/03/19/Linux%E5%91%BD%E4%BB%A4%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%B1%BB%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="Linux命令-文件目录命令"><a href="#Linux命令-文件目录命令" class="headerlink" title="Linux命令-文件目录命令"></a><p align="center">Linux命令-文件目录命令</p></h2><p align="right">记录人：霖雨成思</p><h3 id="命令基础"><a href="#命令基础" class="headerlink" title="命令基础"></a>命令基础</h3><p>Linux命令是严格区分大小写的，<br>登录后会显示一个Shell提示符，普通用户的提示符是$，root用户的提示符是#；<br>查看日期时间：date<br>队列：可以一次提交多条命令，命令之间用分号（;）隔开，Linux会依次执行<br>清屏：clear<br>强制换行：先输入反斜杠（\）再回车<br>输出：echo“ ”<br>查找文件：find / -size +50M（表示在根目录查找文件大小为大于50M的文件）<br>例如:find  -name、文件路径或类型(-type f 表示类型必须是普通文件)<br>例如:把文件找出来删掉:find / -size +100M -type f -exec rm -rf {} ; (-exec是执行的意思，找到某些符合条件的命令后，执行后面的命令    {};代表的是我们找到的这个对象  具体执行的命令是用rm把他删掉，然后用rf选项的作用是强制递归)<br>命令置于后台：命令后加一个&amp;</p><h4 id="文件目录类命令"><a href="#文件目录类命令" class="headerlink" title="文件目录类命令"></a>文件目录类命令</h4><p>列出某个目录下文件的信息：ls （-l长格式输出）（-a显示隐藏文件）（–help获取该命令的帮助）（-R目录递归通过）（-ld目录和符号链接信息）</p><h3 id="文件目录命令1"><a href="#文件目录命令1" class="headerlink" title="文件目录命令1"></a>文件目录命令1</h3><p>列出当前工作路径的命令：pwd<br>改变工作路径：cd（..访问父目录；.当前目录）<br>显示文本文件的内容：cat（适用于查看小文件）<br>输出重定向（在其他文件中查看制定目录）：文件名 &gt; 文件名（如果不存在自动创建，已经存在则会覆盖里面的内容，&gt;&gt;表示追加内容；相当于复制了一份）<br>    如果没有输入被输出文件，则会进入键盘输入制定内容，Ctrl+D提交（优点：快速创建小文件）<br>查看内容较长的文件：more +50（回车下一行，空格切一页，50行为一页，只能向下翻页）<br>查看文件：less（可以上下左右翻页，按Q键退出）<br>显示文件前若干行：head 5（前5行）<br>显示文件后若干行：tail 5（后5行）<br>创建目录：mkdir -p a/b/c（-p表示创建多层目录，abc为想要创建的目录）<br>删除空目录：rmdir（必须为空目录，与mkdir作用反之，方法相同）<br>复制文件：cp a b（必须有两个参数）<br>复制目录：cp -R a b<br>剪切、重命名文件（移动文件）：mv a b<br>i选项：执行询问（输入y回车表示确定，反之为n）<br>f选项：强制操作<br>r选项：递归<br>删除文件：rm</p><blockquote><p>注意：rm -rf /千万不要执行，尤其使用root账户，这个命令会将你的Linux系统根分区全部清空（格式化）<br>快速创建一个新文件：touch（如果后面的参数对应的文件不存在，就快速创建这个文件，如果这个文件已经存在了则把它的修改时间更新为当前的时间）<br>比较两个文件的区别：diff</p></blockquote><hr><p><strong>硬链接</strong><br>创建链接：ln（默认每个文件链接数初始为1）</p><blockquote><p>链接数：是指向磁盘上这个文件数据存储位置的逻辑上的文件名的个数<br>例如：ln b c 表示为b文件创建一个链接为c，此时b文件的链接数由1变为2，而同时多了一个c文件，c的链接数也是2<br>ln命令默认创建的是硬链接，也就是说，b和c对应磁盘上同一块空间，只是逻辑上是两个文件，但在物理磁盘上，是同一块空间<br>此时删除c，b不会有影响，但指向这个逻辑磁盘数少了一个，链接数由2变为1<br><strong>软链接</strong><br>创建链接：ln -s b c（符号链接/软链接）<br>创建后，b的链接数还是1，此时c文件是一个符号链接文件<br>c删掉后，b也不会受到影响<br>所谓符号链接，有点像Windows系统中的创建快捷方式</p></blockquote><h3 id="文件目录命令2"><a href="#文件目录命令2" class="headerlink" title="文件目录命令2"></a>文件目录命令2</h3><p>压缩文件命令：gzip -v（表示显示压缩详情信息）压缩后替代原始文件<br>解压文件命令：gunzip -v（表示显示解压详情信息）解压后替代原始文件<br>目录不能压缩，首先需要归档（就是打包，即把它变成一个普通文件，对应的文件扩展名是.tar）<br>在Windows中，文件夹解压可以直接操作，但在Linux下需要分两步：先（tar）归档，再gzip（压缩）<br>z调用gzip；<br>c，create创建归档文件；<br>f，制定file文件名<br>v，view查看信息<br>通常zcvf一起用（tar -zcvf 文件夹），我们从网上下载的Linux文件很多都是.tar.gz这种格式的，意味着都是对目录先归档再压缩生成的。tar -zxvf还原<br>使用RPM命令安装软件包：</p><blockquote><p>软件仓库<br>yum install 软件名称</p></blockquote><blockquote><p>RPM：RedHat Package Manage红帽软件包管理<br>在官网下载相应软件后，deb适用Ubuntu系统，我用的是centos，所以选rpm<br>通常安装命令：rpm -ivh 文件<br>查询软件包安装信息 rpm -qa(把所有已经安装的软件包信息列出来）<br>产看软件包现在是否已经安装：<br>管道操作：“|”叫做管道符，管道的意思是说：把前面命令执行的输出，作为后面命令的输入，相当于一个管子把他们对接了起来<br>grep用来找一个文件里面查找指定的<strong>关键字</strong>，有的话把对应的行显示出来(-n 表示把关键字的前后n行一并显示)<br>查看系统是否安装某个软件包：rpm -qa  软件<br>删除软件包：rpm -e 软件包名<br>查询命令：–help（善于查参数或选项）<br>          man 命令（善于查函数）</p></blockquote><h3 id="文件目录命令3"><a href="#文件目录命令3" class="headerlink" title="文件目录命令3"></a>文件目录命令3</h3><p>列出<strong>命令</strong>在当前系统中磁盘位置的命令:whertis<br>列出某个命令的一句话的介绍:whatis (不是每个程序都有whatis的命令解释)<br>详细说明：–”help”</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux命令——基础</title>
    <link href="/2020/03/17/Linux%E5%91%BD%E4%BB%A4%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/03/17/Linux%E5%91%BD%E4%BB%A4%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a><p align="center">Linux命令</p></h2><h3 id="命令基础"><a href="#命令基础" class="headerlink" title="命令基础"></a>命令基础</h3><p>Linux命令是严格区分大小写的，<br>登录后会显示一个Shell提示符，普通用户的提示符是$，root用户的提示符是#；<br>查看日期时间：date<br>队列：可以一次提交多条命令，命令之间用分号（;）隔开，Linux会依次执行<br>清屏：clear<br>强制换行：先输入反斜杠（\）再回车<br>输出：echo“ ”<br>查找文件：find / -size +50M（表示在根目录查找文件大小为大于50M的文件）<br>命令置于后台：命令后加一个&amp;</p><h4 id="文件目录类命令"><a href="#文件目录类命令" class="headerlink" title="文件目录类命令"></a>文件目录类命令</h4><p>列出某个目录下文件的信息：ls （-l长格式输出）（-a显示隐藏文件）（–help获取该命令的帮助）</p><h3 id="文件目录命令1"><a href="#文件目录命令1" class="headerlink" title="文件目录命令1"></a>文件目录命令1</h3><p>列出当前工作路径的命令：pwd<br>改变工作路径：cd（..访问父目录；.当前目录）<br>显示文本文件的内容：cat（适用于查看小文件）<br>输出重定向（在其他文件中查看制定目录）：文件名 &gt; 文件名（如果不存在自动创建，已经存在则会覆盖里面的内容，&gt;&gt;表示追加内容；相当于复制了一份）<br>    如果没有输入被输出文件，则会进入键盘输入制定内容，Ctrl+D提交（优点：快速创建小文件）<br>查看内容较长的文件：more +50（回车下一行，空格切一页，50行为一页，只能向下翻页）<br>查看文件：less（可以上下左右翻页，按Q键退出）<br>显示文件前若干行：head 5（前5行）<br>显示文件后若干行：tail 5（后5行）<br>创建目录：mkdir -p a/b/c（-p表示创建多层目录，abc为想要创建的目录）<br>删除空目录：rmdir（必须为空目录，与mkdir作用反之，方法相同）<br>复制文件：cp a b（必须有两个参数）<br>复制目录：cp -R a b<br>重命名文件（移动文件）：mv a b<br>i选项：执行询问（输入y回车表示确定，反之为n）<br>f选项：强制操作<br>r选项：递归<br>删除文件：rm</p><blockquote><p>注意：rm -rf /千万不要执行，尤其使用root账户，这个命令会将你的Linux系统根分区全部清空（格式化）<br>快速创建一个新文件：touch（如果后面的参数对应的文件不存在，就快速创建这个文件，如果这个文件已经存在了则把它的修改时间更新为当前的时间）<br>比较两个文件的区别：diff</p></blockquote><hr><p><strong>硬链接</strong><br>创建链接：ln（默认每个文件链接数初始为1）</p><blockquote><p>链接数：是指向磁盘上这个文件数据存储位置的逻辑上的文件名的个数<br>例如：ln b c 表示为b文件创建一个链接为c，此时b文件的链接数由1变为2，而同时多了一个c文件，c的链接数也是2<br>ln命令默认创建的是硬链接，也就是说，b和c对应磁盘上同一块空间，只是逻辑上是两个文件，但在物理磁盘上，是同一块空间<br>此时删除c，b不会有影响，但指向这个逻辑磁盘数少了一个，链接数由2变为1<br><strong>软链接</strong><br>创建链接：ln -s b c（符号链接/软链接）<br>创建后，b的链接数还是1，此时c文件是一个符号链接文件<br>c删掉后，b也不会受到影响<br>所谓符号链接，有点像Windows系统中的创建快捷方式</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux网络配置</title>
    <link href="/2020/02/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
    <url>/2020/02/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="Linux网络设置"><a href="#Linux网络设置" class="headerlink" title="Linux网络设置"></a><p align="center">Linux网络设置</p></h2><blockquote><p>在视频课中学习的<strong><em>Linux</em></strong>知识做的笔记，包括修改IP、网关、DNS、子网掩码一些指令和方法。</p><p align="right">记录人：霖雨成思</p></blockquote><h4 id="（在终端命令中）切换root（超级管理员）命令：su"><a href="#（在终端命令中）切换root（超级管理员）命令：su" class="headerlink" title="（在终端命令中）切换root（超级管理员）命令：su"></a>（在终端命令中）切换root（超级管理员）命令：<code>su</code></h4><p><img src="/2020/02/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/9.png" srcset="/img/loading.gif" alt="Alt text"></p><p>$表示是普通用户状态，#表示root状态</p><h4 id="（在终端命令中）切换终端：Alt-F1-F2-F3-F4-F5-F6"><a href="#（在终端命令中）切换终端：Alt-F1-F2-F3-F4-F5-F6" class="headerlink" title="（在终端命令中）切换终端：Alt+F1/F2/F3/F4/F5/F6"></a>（在终端命令中）切换终端：Alt+F1/F2/F3/F4/F5/F6</h4><p>每个终端可以有不同的命令，最多有六个终端</p><p>####（在终端命令中） 更改主机名：<code>hostname 修改的主机名（必须在root权限下）</code><br><img src="/2020/02/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/1.png" srcset="/img/loading.gif" alt="Alt text"></p><p>hostname单独写表示查看目前的主机名。注意这种更改只是<strong>临时生效，系统重启会恢复原来的主机名</strong>。</p><p>####（在终端命令下）查看网卡命令：<code>ifconfig</code><br><img src="/2020/02/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/2.png" srcset="/img/loading.gif" alt="Alt text"></p><p>eth0表示第一块以太网卡<br>lo表示虚拟网卡，一般用于测试</p><p>####（在终端命令下）查看所有的网卡命令（包括不活动的网卡）：<code>ifconfig -a</code><br>####（在终端命令下）关闭网卡命令：<code>ifconfig 网卡名称 down （ifdown 网卡名称）</code><br>####（在终端命令下）启用网卡命令：<code>ifconfig 网卡名称 up（ifup 网卡名称）</code><br>####（在终端命令下）更改网卡IP地址命令：<code>ifconfig 网卡名称 更改的IP 网关地址 子网掩码（临时生效）</code><br>不写网关地址和子网掩码则不修改<br>####（在终端命令下）修改网卡的硬件地址【MAC地址（先关闭网卡）】命令：<code>ifconfig 网卡名称 hw ether 新地址（临时生效）</code><br>####（在终端命令下）查看本机的路由表命令：<code>route</code><br>####（在终端命令下）添加网关命令：<code>route add default gw 网关地址（删除则把add换成del）</code></p><h4 id="永久修改主机名：修改-etc-sysconfig-network文件的HOSTNAME属性"><a href="#永久修改主机名：修改-etc-sysconfig-network文件的HOSTNAME属性" class="headerlink" title="永久修改主机名：修改/etc/sysconfig/network文件的HOSTNAME属性"></a>永久修改主机名：修改/etc/sysconfig/network文件的HOSTNAME属性</h4><h4 id="永久修改网卡、IP地址相关的配置文件：修改-etc-sysconfig-network-scripts-ifcfg-eth0-网卡名"><a href="#永久修改网卡、IP地址相关的配置文件：修改-etc-sysconfig-network-scripts-ifcfg-eth0-网卡名" class="headerlink" title="永久修改网卡、IP地址相关的配置文件：修改/etc/sysconfig/network-scripts/ifcfg-eth0(网卡名)"></a>永久修改网卡、IP地址相关的配置文件：修改/etc/sysconfig/network-scripts/ifcfg-eth0(网卡名)</h4><p><img src="/2020/02/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/8.png" srcset="/img/loading.gif" alt="Alt text"></p><p>其中ONBOOT为no的话<strong>网络开机默认不会自动连接</strong><br>BOOTPROTO默认是dhcp，意思是自动分配IP地址、子网掩码、网关这些信息，如果需要自己手动配置的话，我们需要把这个地方修改为null，然后在下边配置IP地址、子网掩码、网关这些信息<br>####DNS配置文件位置：/etc/resolv.conf<br><img src="/2020/02/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/3.png" srcset="/img/loading.gif" alt="Alt text"></p><h4 id="这里需要注意的是，网络相关的配置文件修改之后，需要重启网络服务才能生效。当然，重启系统也是可以的"><a href="#这里需要注意的是，网络相关的配置文件修改之后，需要重启网络服务才能生效。当然，重启系统也是可以的" class="headerlink" title="这里需要注意的是，网络相关的配置文件修改之后，需要重启网络服务才能生效。当然，重启系统也是可以的"></a>这里需要注意的是，网络相关的配置文件修改之后，需要重启网络服务才能生效。当然，重启系统也是可以的</h4><h4 id="字符界面下修改网络配置也是可以的，使用setup命令，会启动一个配置向导"><a href="#字符界面下修改网络配置也是可以的，使用setup命令，会启动一个配置向导" class="headerlink" title="字符界面下修改网络配置也是可以的，使用setup命令，会启动一个配置向导"></a>字符界面下修改网络配置也是可以的，使用setup命令，会启动一个配置向导</h4><p><img src="/2020/02/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/4.png" srcset="/img/loading.gif" alt="Alt text"></p><hr><p><img src="/2020/02/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/7.png" srcset="/img/loading.gif" alt="Alt text"></p><hr><p><img src="/2020/02/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/5.png" srcset="/img/loading.gif" alt="Alt text"></p><hr><p><img src="/2020/02/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/6.png" srcset="/img/loading.gif" alt="Alt text"></p><h4 id="重启网络服务的命令：service-network-restart"><a href="#重启网络服务的命令：service-network-restart" class="headerlink" title="重启网络服务的命令：service network restart"></a>重启网络服务的命令：<code>service network restart</code></h4><p>这就是修改网络配置的一些常用方法，可以使用命令、配置文件和使用setup向导进行修改，其中setup向导方式和修改配置文件一样都是需要重启网络服务后永久生效的。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo博客搭建</title>
    <link href="/2020/02/28/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <url>/2020/02/28/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="hexo博客搭建"><a href="#hexo博客搭建" class="headerlink" title="hexo博客搭建"></a><p align="center">hexo博客搭建</p></h2><blockquote><p>想说一下这篇博客完全是实战操作，无任何理论。搜索了很多博客，才把自己的博客软件hexo安装完成，就算是做一个笔记吧。<strong>（本篇只讲述了通过hexo搭建博客传到github中去，并更改主题的经历，并不包含域名和云服务器的故事）</strong></p></blockquote><h3 id="首先准备的材料"><a href="#首先准备的材料" class="headerlink" title="首先准备的材料"></a>首先准备的材料</h3><ul><li>Git安装包</li><li>Node.js安装包</li><li>github账户</li></ul><p>接着讲一下这三个材料都怎么获取</p><h4 id="1-Git安装包官方下载地址-https-cdn-npm-taobao-org-dist-git-for-windows-v2-25-0-windows-1-Git-2-25-0-64-bit-exe"><a href="#1-Git安装包官方下载地址-https-cdn-npm-taobao-org-dist-git-for-windows-v2-25-0-windows-1-Git-2-25-0-64-bit-exe" class="headerlink" title="1. Git安装包官方下载地址 https://cdn.npm.taobao.org/dist/git-for-windows/v2.25.0.windows.1/Git-2.25.0-64-bit.exe"></a>1. Git安装包官方下载地址 <a href="https://cdn.npm.taobao.org/dist/git-for-windows/v2.25.0.windows.1/Git-2.25.0-64-bit.exe" target="_blank" rel="noopener">https://cdn.npm.taobao.org/dist/git-for-windows/v2.25.0.windows.1/Git-2.25.0-64-bit.exe</a></h4><p>下载之后安装就可以了，我安装的时候在<strong>Adjusting your PATH environment下，勾选了Use Git from Git Bash only</strong>（默认是第二个选项，我选择了第一个），接下来全点next就可以了，直到安装完成。</p><h4 id="2-Node-js安装包官方下载地址-https-nodejs-org-dist-v12-16-1-node-v12-16-1-x64-msi"><a href="#2-Node-js安装包官方下载地址-https-nodejs-org-dist-v12-16-1-node-v12-16-1-x64-msi" class="headerlink" title="2. Node.js安装包官方下载地址 https://nodejs.org/dist/v12.16.1/node-v12.16.1-x64.msi"></a>2. Node.js安装包官方下载地址 <a href="https://nodejs.org/dist/v12.16.1/node-v12.16.1-x64.msi" target="_blank" rel="noopener">https://nodejs.org/dist/v12.16.1/node-v12.16.1-x64.msi</a></h4><p>同样，下载之后安装，我的电脑安装之后不可以再进行安装了，如果安装过程中有任何问题，可以百度查询。</p><h4 id="3-github账户"><a href="#3-github账户" class="headerlink" title="3. github账户"></a>3. github账户</h4><p>谷歌登录github官网，进行注册就可以了。这里有个坑被我踩到了，因为我在进入这个官网的过程中，实在是“挤”不进去，这个的解决办法是：***在自己电脑Windows/System32/dribers/etc目录中，找到hosts文件进入编辑，最下方输入<br># Github start<br>192.30.253.112 github.com<br>192.30.253.119 gist.github.com<br>151.101.100.133 assets-cdn.github.com<br>151.101.100.133 raw.githubusercontent.com<br>151.101.100.133 gist.githubusercontent.com<br>151.101.100.133 cloud.githubusercontent.com<br>151.101.100.133 camo.githubusercontent.com<br>151.101.100.133 avatars0.githubusercontent.com<br>151.101.100.133 avatars1.githubusercontent.com<br>151.101.100.133 avatars2.githubusercontent.com<br>151.101.100.133 avatars3.githubusercontent.com<br>151.101.100.133 avatars4.githubusercontent.com<br>151.101.100.133 avatars5.githubusercontent.com<br>151.101.100.133 avatars6.githubusercontent.com<br>151.101.100.133 avatars7.githubusercontent.com<br>151.101.100.133 avatars8.githubusercontent.com<br>192.30.253.113 github.com<br>192.30.253.113 github.com<br>192.30.253.118 gist.github.com<br>192.30.253.119 gist.github.com<br># Github end<br>就可以了，这里想说一下，最好用谷歌浏览器，因为我在许多地方发现，谷歌浏览器进入特别快。</p><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><h4 id="1-首先在一个位置新建一个空文件夹，名字任意，点进去右键选择Git-Bash-Here（如果没有则是Git安装失败）"><a href="#1-首先在一个位置新建一个空文件夹，名字任意，点进去右键选择Git-Bash-Here（如果没有则是Git安装失败）" class="headerlink" title="1. 首先在一个位置新建一个空文件夹，名字任意，点进去右键选择Git Bash Here（如果没有则是Git安装失败）"></a>1. 首先在一个位置新建一个空文件夹，名字任意，点进去右键选择Git Bash Here（如果没有则是Git安装失败）</h4><h4 id="2-安装hexo的命令："><a href="#2-安装hexo的命令：" class="headerlink" title="2.安装hexo的命令："></a>2.安装hexo的命令：</h4><pre><code>npm install -g hexo-cli</code></pre><p>这一步会很慢很慢。。。再次弹出$ 就可能表示已经成功了，输入hexo -v进行检查，弹出这个就表示成功了</p><pre><code>$ hexo -vhexo: 3.4.2hexo-cli: 1.0.4os: Windows_NT 6.1.7601 win32 x64http_parser: 2.7.0node: 8.9.1v8: 6.1.534.47uv: 1.15.0zlib: 1.2.11ares: 1.10.1-DEVmodules: 57nghttp2: 1.25.0openssl: 1.0.2micu: 59.1unicode: 9.0cldr: 31.0.1tz: 2017b</code></pre><p>继续输入hexo init来初始化hexo，注意，这个是分四次输入的</p><pre><code>hexo inithexo installnpm install hexo-deployer-git --save</code></pre><p>初始化之后，会有一个默认主题和文章，也就是我们的博客</p><pre><code>hexo server //可以简写成hexo s(这是注释)</code></pre><p>这个时候就可以通过浏览器浏览本机端口号4000的默认博客啦！(这里有些细节不一样是因为我后改了一些)。Ctrl+C可以结束</p><p><img src="/2020/02/28/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/4.png" srcset="/img/loading.gif" alt="Alt text"></p><p>我们在先暂时不更改默认博客文章的前提下，把本地文章发布到网上，让更多的人看到，这个时候就需要Github账户了<br>下面安装图片提示创建库<br>之前推荐谷歌浏览器，有一部分因为翻译成简体中文比较方便<br><img src="/2020/02/28/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/3.png" srcset="/img/loading.gif" alt="Alt text"></p><hr><p>接着创建新的库名<br><img src="/2020/02/28/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/POS.png" srcset="/img/loading.gif" alt="Alt text"></p><hr><p>这个地方注意，名称一定是你的github用户名.github.io，之前我因为打错一个字母，结果。。。坑炸了</p><p><img src="/2020/02/28/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/1.png" srcset="/img/loading.gif" alt="Alt text"></p><hr><p>创建好了之后，如下图，库里是空的，复制箭头指向的地址<br><img src="/2020/02/28/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/2.png" srcset="/img/loading.gif" alt="Alt text"></p><hr><p>然后回到自己建的文件夹中找到_config.yml进入编辑，拉到最下边，改成下图所示，并保存</p><pre><code>deploy:  type: git  repo: //刚才自己复制的地址粘贴到这里  branch: master</code></pre><p>然后再到Git Bash中输入hexo g 将本地的博客文章上传到github中去</p><pre><code>hexo d</code></pre><p>等待完成后，浏览器输入<strong>你的githubID.github.io</strong>回车，就会看到上帝的微笑了^_^</p><p>这样，就不止自己能看到了，别人输入上边的地址搜索，也能看到自己的博客。<strong>每当在本地修改一次，就重新部署上传一次</strong>，重新部署主题也是，和上边代码一样，但我一般都先清空缓存一次（分两次输入）</p><pre><code>hexo cleanhexo d</code></pre><h3 id="如何更换主题和发布文章"><a href="#如何更换主题和发布文章" class="headerlink" title="如何更换主题和发布文章"></a>如何更换主题和发布文章</h3><h4 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h4><p>hexo官网上有很多漂亮帅气的主题，每个主题也有部署方法和讲解，我举一个例子：<br>进入hexo官网之后，点击主题<br><img src="/2020/02/28/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%7DGWDEUB%7D~8ZO~PBVU5XL_6M.png" srcset="/img/loading.gif" alt="Alt text"></p><hr><p>之后选择一个自己喜欢的主题点进去<br><img src="/2020/02/28/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/0BVIN8APMA%7DHF2SA8Z0BJN.png" srcset="/img/loading.gif" alt="Alt text"></p><hr><p>里面就有详细的部署方法，比较常见的几步差不多就是</p><ul><li>下载资源，放到themes文件夹中</li><li>将_config.yml文件中的theme后的默认主题landscape更换成新下载的主题</li><li>hexo clean、hexo d清除缓存后发布</li></ul><p>当然，具体操作步骤还是参考主题发布者（官方）的说明书<br>更换完主题hexo clean和hexo s 在本地看一看，然后就可以hexo d发布到github中去了，主题也就随之更换</p><h4 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h4><p>发布文章的话，就在博客文件夹中的sourse文件夹下的_posts下，创建.md文件（markdown语言的文件，可以百度搜索一下），目前没有创建任何文章的情况下，一定会只有一个hello-world.md的文档，可以把这个文档中的开头三行复制过来，把title改一下就行了。因为- - -这种格式会被收录到目录中去。在下边就可以大刀阔斧的编写自己行编写的博客了！编写好了之后保存，在GitBash中同上，hexo clean 和hexo d两条命令发布到github中去。具体markdown语言请参考网上学习资料或视频学习，自认为还是很简单的。<br>我的服务器和域名搭建参考的wang2000博客是<a href="https://www.cnblogs.com/luqwer/p/11328600.html" target="_blank" rel="noopener">https://www.cnblogs.com/luqwer/p/11328600.html</a> 还是很有帮助的。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>我的第一篇博客文章</title>
    <link href="/2020/02/27/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"/>
    <url>/2020/02/27/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/02/26/hello-world/"/>
    <url>/2020/02/26/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
