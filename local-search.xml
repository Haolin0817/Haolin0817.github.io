<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>VMware虚拟机提示：以独占方式锁定此配置文件失败</title>
    <link href="/2020/06/02/VMware%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%8F%90%E7%A4%BA%EF%BC%9A%E4%BB%A5%E7%8B%AC%E5%8D%A0%E6%96%B9%E5%BC%8F%E9%94%81%E5%AE%9A%E6%AD%A4%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%A4%B1%E8%B4%A5/"/>
    <url>/2020/06/02/VMware%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%8F%90%E7%A4%BA%EF%BC%9A%E4%BB%A5%E7%8B%AC%E5%8D%A0%E6%96%B9%E5%BC%8F%E9%94%81%E5%AE%9A%E6%AD%A4%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%A4%B1%E8%B4%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="VMware虚拟机提示：以独占方式锁定此配置文件失败"><a href="#VMware虚拟机提示：以独占方式锁定此配置文件失败" class="headerlink" title="VMware虚拟机提示：以独占方式锁定此配置文件失败"></a><p align="center">VMware虚拟机提示：以独占方式锁定此配置文件失败</p></h2><p align="right">记录人：霖雨成思VM异常关闭后再次启动，提示“以独占方式锁定此配置文件失败”> 通过禁用启动项的方式结束旧的进程占用<ul><li>按“win + R”组合键，进入“运行”.</li><li>写入“msconfig”进入系统配置</li><li>选中服务，勾选左下角“隐藏所有Microsoft服务”，再点击“全部禁用”，点击应用。</li><li>再打开“服务“边上的“启动”选项，打开“点击任务管理器”</li><li>找到VMware Tray Process，禁用</li><li>重启电脑后，再按照如上方式启动被禁用的服务，VMware就可以正常启动了</li></ul><blockquote><p>参考链接:<a href="https://www.cnblogs.com/Komorebi-john/p/11381053.html" target="_blank" rel="noopener">https://www.cnblogs.com/Komorebi-john/p/11381053.html</a></p></blockquote></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>重新配置JDK后，导致Eclipse打不开</title>
    <link href="/2020/05/31/%E9%87%8D%E6%96%B0%E9%85%8D%E7%BD%AEJDK%E5%90%8E%EF%BC%8C%E5%AF%BC%E8%87%B4Eclipse%E6%89%93%E4%B8%8D%E5%BC%80/"/>
    <url>/2020/05/31/%E9%87%8D%E6%96%B0%E9%85%8D%E7%BD%AEJDK%E5%90%8E%EF%BC%8C%E5%AF%BC%E8%87%B4Eclipse%E6%89%93%E4%B8%8D%E5%BC%80/</url>
    
    <content type="html"><![CDATA[<h2 id="重新配置JDK后，导致Eclipse打不开"><a href="#重新配置JDK后，导致Eclipse打不开" class="headerlink" title="重新配置JDK后，导致Eclipse打不开"></a><p align="center">重新配置JDK后，导致Eclipse打不开</p></h2><p align="right">记录人：霖雨成思</p><p>我在配置Windows版hadoop时将jdk重新安装到了没有中文和空格的路径中，重新配置环境变量后导致eclipse打不开了，我找到了eclipse安装路径，打开了eclipse.ini，加上了</p><pre><code class="ini">-vmC:\file\jdk\jdk8\bin\javaw.exe(这个是我的jdk\bin路径)</code></pre><p>这段代码，就能正常打开了<br>修改之后eclipse.ini是这样的</p><pre><code class="ini">-startupplugins/org.eclipse.equinox.launcher_1.3.201.v20161025-1711.jar--launcher.libraryplugins/org.eclipse.equinox.launcher.win32.win32.x86_64_1.1.401.v20161122-1740-productorg.eclipse.epp.package.jee.product--launcher.defaultActionopenFile-showsplashorg.eclipse.platform--launcher.defaultActionopenFile--launcher.appendVmargs-vmC:\file\jdk\jdk8\bin\javaw.exe-vmargs-Dosgi.requiredJavaVersion=1.8-XX:+UseG1GC-XX:+UseStringDeduplication-Dosgi.requiredJavaVersion=1.8-Xms512m-Xmx1024m</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringAOP-面向切面编程</title>
    <link href="/2020/05/22/SpringAOP-%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/"/>
    <url>/2020/05/22/SpringAOP-%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="SpringAOP-面向切面编程"><a href="#SpringAOP-面向切面编程" class="headerlink" title="SpringAOP-面向切面编程"></a><p align="center">SpringAOP-面向切面编程</p></h2><p align="right">记录人：霖雨成思</p><h4 id="什么是AOP？"><a href="#什么是AOP？" class="headerlink" title="什么是AOP？"></a>什么是AOP？</h4><p>为了将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，Spring提供了面向切面的编程方式，也称Spring AOP，AOP的全称是Aspect Oriented Programing，即面向切面编程。<br>AOP采取横向抽取机制，取代了传统纵向继承体系重复性代码，主要体现在事务处理、日志管理、权限控制、异常处理等方面，使开发人员在编写业务逻辑时可以专心核心业务，提高代码的可维护性。</p><h4 id="AOP术语"><a href="#AOP术语" class="headerlink" title="AOP术语"></a>AOP术语</h4><p>AOP的专业术语包括Joinpoint、Pointcut、Advice、Target、Weaving、Proxy和Aspect，对于专业术语的解释，具体如下：</p><ul><li><p>Joinpoint（连接点）：是指那些被拦截到的点，在Spring中，可以被动态代理拦截目标类的方法。</p></li><li><p>Pointcut（切入点）：是指要对哪些Joinpoint进行拦截，即被拦截的连接点。</p></li><li><p>Advice（通知）：是指拦截到Joinpoint之后要做的事情，即对切入点增强的内容。</p></li><li><p>Target（目标）：是指代理的目标对象。</p></li><li><p>Weaving（织入）：是指把增强代码应用到目标上，生成代理对象的过程。</p></li><li><p>Proxy（代理）：是指生成的代理对象。</p></li><li><p>Aspect（切面）：是切入点和通知的结合。</p><h4 id="手动代理"><a href="#手动代理" class="headerlink" title="手动代理"></a>手动代理</h4><p> 代理模式是 Java 中的常用设计模式，代理类通过调用被代理类的相关方法，提供预处理、过滤、事后处理等服务。AOP手动使用代理模式有两个典型的例子，分别为JDK动态代理和CGLIB代理。为了让读者了解AOP的执行过程，本小节将通过这两种手动代理的实现方式，结合相关案例，模拟AOP的执行过程。</p><h5 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h5><p>JDK动态代理是通过JDK中的java.lang.reflect.Proxy类来实现的。JDK的动态代理用起来非常简单，但是它有局限性，使用动态代理的对象必须实现一个或多个接口。那么，如何代理没有实现接口的类？</p><h4 id="CGLIB代理"><a href="#CGLIB代理" class="headerlink" title="CGLIB代理"></a>CGLIB代理</h4><p>如果想代理没有实现接口的类，那么可以使用CGLIB代理。<br>CGLIB(Code Generation Library)是一个高性能开源的代码生成包，它的底层是通过使用一个小而快的字节码处理框架ASM(Java字节码操控框架)来转换字节码，为一个类创建子类，然后对子类进行增强，解决无接口代理问题。所以CGLIB要依赖于ASM的包</p><h4 id="声明式工厂Bean"><a href="#声明式工厂Bean" class="headerlink" title="声明式工厂Bean"></a>声明式工厂Bean</h4><h5 id="Spring通知类型"><a href="#Spring通知类型" class="headerlink" title="Spring通知类型"></a>Spring通知类型</h5><p>Spring按照通知在目标类方法的连接点位置，可以分为5种类型，具体如下：</p></li><li><p>org.springframework.aop.MethodBeforeAdvice（前置通知）<br>  在目标方法执行前实施增强，可以应用于权限管理等功能。</p></li><li><p>org.springframework.aop.AfterReturningAdvice（后置通知）<br>  在目标方法执行后实施增强，可以应用于关闭流、上传文件、删除临时   文件等功能。</p></li><li><p>org.aopalliance.intercept.MethodInterceptor（环绕通知）<br>  在目标方法执行前后实施增强，可以应用于日志、事务管理等功能。</p></li><li><p>org.springframework.aop.ThrowsAdvice（异常抛出通知）<br>  在方法抛出异常后实施增强，可以应用于处理异常记录日志等功能。</p></li><li><p>org.springframework.aop.IntroductionInterceptor（引介通知）<br> 在目标类中添加一些新的方法和属性，可以应用于修改老版本程序（增强类）。</p><h5 id="声明式Spring-AOP"><a href="#声明式Spring-AOP" class="headerlink" title="声明式Spring AOP"></a>声明式Spring AOP</h5><p> 通过在Spring中创建一个AOP代理的基本方法是，使用org.springframework.aop.framework.ProxyFactoryBean，这个类对应的切入点和通知提供了完整的控制能力，生成指定的内容。该类的常用属性如下<br> <img src="/2020/05/22/SpringAOP-%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/1.png" srcset="/img/loading.gif" alt="Alt text"></p><h5 id="环绕通知"><a href="#环绕通知" class="headerlink" title="环绕通知"></a>环绕通知</h5><p>在Spring通知中，环绕通知是一个非常典型的应用</p><h4 id="Aspect开发"><a href="#Aspect开发" class="headerlink" title="Aspect开发"></a>Aspect开发</h4><p>AspectJ是一个基于Java语言的AOP框架，Spring2.0以后新增了对AspectJ切点表达式的支持。@AspectJ 是AspectJ1.5新增功能，通过JDK5.0注解技术，允许直接在Bean类中定义切面，新版本Spring框架，建议使用AspectJ方式来开发AOP，接下来对两种AspectJ的开发方式进行讲解。</p><h5 id="基于XML的声明式AspectJ"><a href="#基于XML的声明式AspectJ" class="headerlink" title="基于XML的声明式AspectJ"></a>基于XML的声明式AspectJ</h5><p> 基于XML的声明式AspectJ是指，通过在XML文件中进行配置，来定义切面、切入点及声明通知，所有的切面和通知都必须定义在&lt; aop:config &gt;元素内。<br>基于Annotation的声明式AspectJ<br> 基于XML的声明式ApectJ有一个缺点就是要在Spring文件中配置大量的信息。为了解决这个问题，AspectJ框架为AOP提供了一套Annotation注解，用以取代Spring配置文件中为实现AOP功能所配置的臃肿的代码。</p><ul><li>@AspectJ：用于定义一个切面。</li><li>@Before ：用于定义前置通知，相当于BeforeAdvice。</li><li>@AfterReturning：用于定义后置通知，相当于AfterReturningAdvice。</li><li>@Around： 用于定义环绕通知，相当于MethodInterceptor。</li><li>@AfterThrowing： 用于定义抛出通知，相当于ThrowAdvice。</li><li>@After：用于定义最终final通知，不管是否异常，该通知都会执行。</li><li>@DeclareParents：用于定义引介通知，相当于IntroductionInterceptor (不要求掌握)。</li></ul></li></ul><blockquote><p>本文根据哈尔滨华育兴业教师欧阳广靖老师的课记录</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring中的Bean</title>
    <link href="/2020/05/22/Spring%E4%B8%AD%E7%9A%84Bean/"/>
    <url>/2020/05/22/Spring%E4%B8%AD%E7%9A%84Bean/</url>
    
    <content type="html"><![CDATA[<h2 id="Spring中的Bean"><a href="#Spring中的Bean" class="headerlink" title="Spring中的Bean"></a><p align="center">Spring中的Bean</p></h2><p align="right">记录人：霖雨成思</p><h4 id="Bean的配置"><a href="#Bean的配置" class="headerlink" title="Bean的配置"></a>Bean的配置</h4><p>如果把Spring看做一个大型的工厂，而Spring容器中的Bean就是该工厂的产品，要想使用这个工厂生产和管理Bean，就需要在配置文件中告诉它需要哪些Bean，以及需要使用何种方式将这些Bean装配到一起。<br><img src="/2020/05/22/Spring%E4%B8%AD%E7%9A%84Bean/1.png" srcset="/img/loading.gif" alt="Alt text"><br><b>在实际开发中，最常使用的是XML文件格式的配置方式，这种配置方式是通过XML文件来注册并管理Bean之间的依赖关系。</b><br>XML配置文件的根元素是&lt; beans &gt;,&lt; beans &gt;中包含了多个&lt; bean &gt;子元素定义了一个Bean，并描述了该Bean如何被装配到Spring容器中，定义Bean的方式如下所示。</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans            http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!—使用id属性定义bean1,其对应的实现类为cn.itcast.bean1 --&gt;    &lt;bean id=&quot;bean1&quot; class=&quot;cn.itcast.bean1&quot;/&gt;    &lt;!—使用name属性定义bean2,其对应的实现类为cn.itcast.bean2 --&gt;    &lt;bean name=&quot;bean2&quot; class=&quot;cn.itcast.bean2&quot;/&gt;&lt;/beans&gt;</code></pre><blockquote><p>通常一个普通的Bean只需要定义id（或name）和class两个属性即可，如果Bean中未指定id和name，则Spring会将class值当做id使用。</p></blockquote><h4 id="Bean的实例化"><a href="#Bean的实例化" class="headerlink" title="Bean的实例化"></a>Bean的实例化</h4><p>在面向对象的程序中，要想使用某个对象，就需要先实例化这个对象。在Spring中，实例化Bean有三种方式，分别为构造器实例化、静态工厂实例化和实例化工厂方式实例化。</p><ul><li><b>构造器实例化</b>是指Spring容器通过Bean对应的类中默认的构造函数来实例化Bean。</li><li>使用<b>静态工厂</b>是实例化Bean的另一种方式，该方式要求自己创建一个静态工厂的方法来创建Bean的实例</li><li><b>实例化工厂方式</b>的工厂类中看，不再使用静态方法创建Bean实例，而是采用直接创建Bean实例的方式。同时，在配置文件中，需要实例化的Bean也不是通过class属性直接指向其实例化的类，而是通过factory-bean属性配置一个实例工厂，然后使用factory-method属性确定使用工厂中的哪个方法。<h4 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h4><h5 id="作用域的种类"><a href="#作用域的种类" class="headerlink" title="作用域的种类"></a>作用域的种类</h5>Spring3为Bean实例定义了五种Bean的作用域，这五种作用域说明如下所示。</li><li>singleton：单例模式，使用singleton定义的bean在Spring容器中将只有一个实例，也就是说，无论有多少个Bean引用它，始终将指向同一个对象。这也是Spring容器默认的作用域。</li><li>prototype：原型模式，每次通过Spring容器获取的prototype定义的Bean时，容器都将创建一个新的Bean实例。</li><li>request：在一次HTTP请求中，容器会返回该Bean的同一个实例。而对不同的HTTP请求则会产生一个新的Bean，而且该Bean仅在当前HTTP Request内有效。</li><li>session：在一次HTTP Session中，容器会返回该Bean的同一个实例。而对不同的HTTP请求则会产生一个新的Bean，而且该Bean仅在当前HTTP Session内有效。</li><li>global Session：在一个全局的HTTP Session中，容器会返回该Bean的同一个实例。仅在使用portlet context时有效。<h6 id="Singleton作用域"><a href="#Singleton作用域" class="headerlink" title="Singleton作用域"></a>Singleton作用域</h6>Singleton作用域是Spring容器默认的作用域，当一个bean的作用域为singleton时，Spring容器中只会存在一个共享的Bean实例，并且所有对bean的请求，只要id与该bean定义相匹配的，就只会返回Bean的同一个实例。<br>在Spring配置文件中，可以使用bean元素的scope属性，将Bean的作用域定义成singleton。例如：<pre><code class="xml">&lt;bean id=&quot;hello&quot; class=&quot;cn.itcast.hello.Hello&quot; scope=&quot;singleton&quot;/&gt;</code></pre><h6 id="Prototype作用域"><a href="#Prototype作用域" class="headerlink" title="Prototype作用域"></a>Prototype作用域</h6>对需要保持会话状态的Bean（如Struts 2的Action类）应该使用prototype作用域。在使用Prototype作用域时，Spring容器会为每个对该Bean的请求都创建一个新的实例。<br>要将Bean定义为prototype，只需在xml文件中将&lt; bean &gt;元素的scope属性的值设置为prototype即可。例如：<pre><code class="xml">&lt;bean id=&quot;hello&quot; class=&quot;cn.itcast.hello.Hello&quot; scope=&quot;prototype &quot;/&gt;</code></pre><h4 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h4>接下来，将在Bean作用域的基础上讲解Bean的生命周期。Spring生命周期的意义就在于，可以利用Bean在其存活期间的指定时刻完成一些相关操作。这种时刻可能有很多，但一般情况下，常会在Bean的postin<br>itiation(初始化后)和predestruction（销毁前）执行一些相关操作。<br>Spring容器中Bean的声明周期流程如图所示。<br><img src="/2020/05/22/Spring%E4%B8%AD%E7%9A%84Bean/1.png" srcset="/img/loading.gif" alt="Alt text"><h4 id="Bean的装配方式"><a href="#Bean的装配方式" class="headerlink" title="Bean的装配方式"></a>Bean的装配方式</h4>Bean的装配可以理解为依赖关系注入，Bean的装配方式即Bean依赖注入的方式。Spring容器支持多种形式的Bean的装配方式，如基于XML的装配、基于Annotation的装配和自动装配等，本节中将主要讲解这三种装配方式的使用。</li></ul><h5 id="基于XML的装配"><a href="#基于XML的装配" class="headerlink" title="基于XML的装配"></a>基于XML的装配</h5><p><img src="/2020/05/22/Spring%E4%B8%AD%E7%9A%84Bean/1.png" srcset="/img/loading.gif" alt="Alt text"></p><ul><li>设值注入(Setter Injection)<br> 设值注入要求一个Bean必须满足以下两点要求：<br><b>√</b>  Bean类必须提供一个默认的构造方法。<br><b>√</b> Bean类必须为需要注入的属性提供对应的set方法。<br> 使用设值注入时，在Spring配置文件中，需要使用&lt; bean &gt;元素的子元素&lt; property &gt;元素来为每个属性注入值。</li><li>构造注入<br>使用构造注入时，在配置文件里，主要是使用&lt; constructor-arg &gt;标签来定义构造方法的参数，可以使用其value属性（或子元素）来设置该参数的值<h5 id="基于Annotation的装配"><a href="#基于Annotation的装配" class="headerlink" title="基于Annotation的装配"></a>基于Annotation的装配</h5>在Spring中，尽管使用XML配置文件可以实现Bean的装配工作，但如果应用中有很多Bean时，会导致XML配置文件过于臃肿，给后续的维护和升级工作带来一定的困难。为此，Java从JDK1.5以后，提供了Annotation（注解）功能，Spring也提供了对Annotation技术的全面支持。</li></ul><ul><li>@Component ：可以使用此注解描述Spring中的Bean，但它是一个泛化的概念，仅仅表示一个组件 (Bean) ，并且可以作用在 - 任何层次。使用时只需将该注解标注在相应类上即可。</li><li>@Repository：用于将数据访问层 (DAO 层 ) 的类标识为Spring中的Bean，其功能与 @Component 相同。</li><li>@Service：通常作用在业务层（Service层），用于将业务层的类标识为Spring中的Bean，其功能与 @Component 相同。</li><li>@Constroller：通常作用在控制层（如Struts2的Action），用于将控制层的类标识为Spring中的Bean，其功能与@Component 相同。</li><li>@Autowired：用于对Bean的属性变量、属性的Set方法及构造函数进行标注，配合对应的注解处理器完成Bean的自动配置工作。默认按照Bean的类型进行装配。</li><li>@Resource：其作用与Autowired一样。其区别在于@Autowired默认按照Bean类型装配，而@Resource默认按照Bean实例名称进行装配。@Resource中有两个重要属性：name和type。Spring将name属性解析为Bean实例名称，type属性解析为Bean实例类型。如果指定name属性，则按实例名称进行装配；如果指定type属性，则按Bean类型进行装配；如果都不指定，则先按Bean实例名称装配，如果不能匹配，再按照Bean类型进行装配；如果都无法匹配，则抛出NoSuchBeanDefinitionException异常。</li><li>@Qualifier：与@Autowired注解配合使用，会将默认的按Bean类型装配修改为按Bean的实例名称装配，Bean的实例名称由@Qualifier注解的参数指定。<h5 id="自动自动装配"><a href="#自动自动装配" class="headerlink" title="自动自动装配"></a>自动自动装配</h5>自动装配就是讲一个Bean注入到其他Bean的Property中，要使用自动装配，就需要配置&lt; bean &gt;元素的autowire属性。</li></ul><p> autowire属性有5个值，其值说明如下所示。</p><ul><li>byName：根据Property的Name自动装配，如果一个bean的name，和另一个bean中的Property的name相同，则自动装配这个bean到Property中。</li><li>byType：根据Property的数据类型（Type）自动装配，如果一个bean的数据类型，兼容另一个bean中Property的数据类型，则自动装配。</li><li>constructor：根据构造函数参数的数据类型，进行byType模式的自动装配。</li><li>autodetect：如果发现默认的构造函数，用constructor模式，否则用byType模式。</li><li>no：默认情况下，不使用自动装配，Bean依赖必须通过ref元素定义。</li></ul><blockquote><p>本文根据哈尔滨华育兴业教师欧阳广靖老师的课记录</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring的基本应用</title>
    <link href="/2020/05/22/Spring%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8/"/>
    <url>/2020/05/22/Spring%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="Spring的基本应用"><a href="#Spring的基本应用" class="headerlink" title="Spring的基本应用"></a><p align="center">Spring的基本应用</p></h2><p align="right">记录人：霖雨成思</p><h4 id="什么是Spring"><a href="#什么是Spring" class="headerlink" title="什么是Spring?"></a>什么是Spring?</h4><blockquote><p>   Spring是分层的JavaSE/EE full-stack 轻量级开源框架，以IoC（Inverse of Control 控制反转）和AOP（Aspect Oriented Programming 面向切面编程）为内核，使用基本的JavaBean来完成以前只可能由EJB完成的工作，取代了EJB的臃肿、低效的开发模式。</p></blockquote><p>   在实际开发中，通常服务器端在采用三层体系架构，分别为表示层(web)、业务逻辑层(service)、持久层(dao)， Spring对每一层都提供了技术支持。</p><p><img src="/2020/05/22/Spring%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8/1.png" srcset="/img/loading.gif" alt="Alt text"></p><h5 id="Spring框架的优点"><a href="#Spring框架的优点" class="headerlink" title="Spring框架的优点"></a>Spring框架的优点</h5><p>Spring具有简单、可测试和松耦合的特点，从这个角度出发，Spring不仅可以用于服务器端开发，也可以应用于任何Java应用的开发中。</p><ul><li>方便解耦 ，简化开发</li><li>AOP编程的支持</li><li>声明式事物的支持</li><li>方便程序的测试</li><li>方便集成各种优秀框架</li><li>降低JavaEE API的使用难度<h5 id="Spring的体系结构"><a href="#Spring的体系结构" class="headerlink" title="Spring的体系结构"></a>Spring的体系结构</h5>Spring框架采用分层架构，如下图所示<br><img src="/2020/05/22/Spring%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8/2.png" srcset="/img/loading.gif" alt="Alt text"><h6 id="1-Core-Container-核心容器"><a href="#1-Core-Container-核心容器" class="headerlink" title="1.Core Container(核心容器)"></a>1.Core Container(核心容器)</h6>Spring的核心容器是其他模块建立的基础，由Beans模块、Core核心模块、Context上下模块和Expression Language表达式语言模块组成。<br><img src="/2020/05/22/Spring%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8/3.png" srcset="/img/loading.gif" alt="Alt text"><h6 id="2-Data-Access-Integration（数据访问-集成）"><a href="#2-Data-Access-Integration（数据访问-集成）" class="headerlink" title="2.Data Access/Integration（数据访问/集成）"></a>2.Data Access/Integration（数据访问/集成）</h6>数据访问/集成层包括JDBC、ORM、OXM，JMS和Transaction模块<br><img src="/2020/05/22/Spring%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8/4.png" srcset="/img/loading.gif" alt="Alt text"><h6 id="3-Web模块"><a href="#3-Web模块" class="headerlink" title="3.Web模块"></a>3.Web模块</h6>Spring的Web层包括web、Servlet、Struts和Portlet组件<br><img src="/2020/05/22/Spring%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8/5.png" srcset="/img/loading.gif" alt="Alt text"><h6 id="4-其他模块"><a href="#4-其他模块" class="headerlink" title="4.其他模块"></a>4.其他模块</h6>Spring的其他模块还有AOP、Aspects、Instruction以及Test模块。 </li></ul><h4 id="Spring的IOC容器"><a href="#Spring的IOC容器" class="headerlink" title="Spring的IOC容器"></a>Spring的IOC容器</h4><p>Spring容器会负责控制程序之间的关系，而不是由程序代码直接控制，这样控制权由应用代码转移到了外部容器，控制权发生了反转，也就是Spring的IoC（控制反转）思想。Spring为我们提供了两种IoC容器，分别为BeanFactory和ApplicationContext，本节将对这两种IoC容器进行简单介绍。</p><h5 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h5><p>  BeanFactory是基础类型的IoC容器，由org.springframework.beans.facytory.BeanFactory接口定义，并提供了完整的IoC服务支持。它主要负责初始化各种Bean，并调用它们的生命周期方法。</p><p>BeanFactory接口最常见的是使用 org.springframework.beans.factory.xml.Xml<br>BeanFactory根据XML配置文件中的定义来装配Bean。创建BeanFactory实例时，需要提供Spring所管理容器的详细配置信息，这些信息通常采用XML文件形式来管理。<br>例如：</p><pre><code>BeanFactory beanFactory = new XmlBeanFactory(new FileSystemResource(&quot;F:/applicationContext.xml&quot;));</code></pre><h5 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h5><p>ApplicationContext是BeanFactory的子接口，也被称为应用上下文。该接口的 全路径为org.springframework.context. ApplicationContext，在BeanFactory所有的功能的基础上进行了增强。<br><img src="/2020/05/22/Spring%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8/6.png" srcset="/img/loading.gif" alt="Alt text"><br><img src="/2020/05/22/Spring%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8/111.png" srcset="/img/loading.gif" alt="Alt text"></p><h4 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h4><p>DI的全称是Dependency Injection，中文称之为依赖注入。它与控制反转的含义相同，只不过这两个称呼是从两个角度描述的同一个概念。<br>     依赖注入的作用就是在使用Spring框架创建对象时，动态的将其所依赖的对象注入到Bean组件中。<br>  依赖注入存在三种实现方式，分别是setter方法注入、构造方法注入和接口注入。<br>  <img src="/2020/05/22/Spring%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8/7.png" srcset="/img/loading.gif" alt="Alt text"></p><blockquote><p>本文根据哈尔滨华育兴业教师欧阳广靖老师的课记录</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Struts2拦截器</title>
    <link href="/2020/05/15/Struts2%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    <url>/2020/05/15/Struts2%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="Struts2拦截器"><a href="#Struts2拦截器" class="headerlink" title="Struts2拦截器"></a><p align="center">Struts2拦截器</p></h2><p align="right">记录人：霖雨成思</p><h4 id="Struts2架构剖析"><a href="#Struts2架构剖析" class="headerlink" title="Struts2架构剖析"></a>Struts2架构剖析</h4><p><img src="/2020/05/15/Struts2%E6%8B%A6%E6%88%AA%E5%99%A8/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200515122225.png" srcset="/img/loading.gif" alt="Alt text"></p><h4 id="核心接口和类"><a href="#核心接口和类" class="headerlink" title="核心接口和类"></a>核心接口和类</h4><p><img src="/2020/05/15/Struts2%E6%8B%A6%E6%88%AA%E5%99%A8/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200515122450.png" srcset="/img/loading.gif" alt="Alt text"><br><img src="/2020/05/15/Struts2%E6%8B%A6%E6%88%AA%E5%99%A8/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_202005151224501.png" srcset="/img/loading.gif" alt="Alt text"></p><h4 id="为什么需要拦截器"><a href="#为什么需要拦截器" class="headerlink" title="为什么需要拦截器"></a>为什么需要拦截器</h4><ul><li>早期MVC框架框架将一些通用操作硬编码在核心控制器中，致使框架灵活性不足、可扩展性降低</li><li>Struts2将核心功能放到多个拦截器中实现，拦截器可自由选择和组合，增强了灵活性，有利于系统的解耦</li></ul><h5 id="Struts2大多数核心功能时通过拦截器实现的，每个拦截器完成某项功能"><a href="#Struts2大多数核心功能时通过拦截器实现的，每个拦截器完成某项功能" class="headerlink" title="Struts2大多数核心功能时通过拦截器实现的，每个拦截器完成某项功能"></a>Struts2大多数核心功能时通过拦截器实现的，每个拦截器完成某项功能</h5><h5 id="拦截器方法在Action执行之前喝之后执行"><a href="#拦截器方法在Action执行之前喝之后执行" class="headerlink" title="拦截器方法在Action执行之前喝之后执行"></a>拦截器方法在Action执行之前喝之后执行</h5><h5 id="拦截器栈"><a href="#拦截器栈" class="headerlink" title="拦截器栈"></a>拦截器栈</h5><ul><li>从结构上看，拦截器栈相当于多个拦截器的组合</li><li>在功能上，拦截器也是拦截器<h5 id="拦截器与过滤器原理很相似"><a href="#拦截器与过滤器原理很相似" class="headerlink" title="拦截器与过滤器原理很相似"></a>拦截器与过滤器原理很相似</h5><blockquote><p>经验：<br>为Action提供附加功能时，无需修改Action代码，使用拦截器来提供</p></blockquote></li></ul><h6 id="拦截器的执行过程是一个递归的过程"><a href="#拦截器的执行过程是一个递归的过程" class="headerlink" title="拦截器的执行过程是一个递归的过程"></a>拦截器的执行过程是一个递归的过程</h6><p><img src="/2020/05/15/Struts2%E6%8B%A6%E6%88%AA%E5%99%A8/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_202005151222251.png" srcset="/img/loading.gif" alt="Alt text"></p><p><img src="/2020/05/15/Struts2%E6%8B%A6%E6%88%AA%E5%99%A8/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_202005151222252.png" srcset="/img/loading.gif" alt="Alt text"><br><img src="/2020/05/15/Struts2%E6%8B%A6%E6%88%AA%E5%99%A8/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_202005151222253.png" srcset="/img/loading.gif" alt="Alt text"><br><img src="/2020/05/15/Struts2%E6%8B%A6%E6%88%AA%E5%99%A8/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_202005151222254.png" srcset="/img/loading.gif" alt="Alt text"></p><h4 id="Struts2自带拦截器"><a href="#Struts2自带拦截器" class="headerlink" title="Struts2自带拦截器"></a>Struts2自带拦截器</h4><h5 id="params拦截器"><a href="#params拦截器" class="headerlink" title="params拦截器"></a>params拦截器</h5><ul><li>负责将请求参数设置为Action属性<h5 id="servletConfig拦截器"><a href="#servletConfig拦截器" class="headerlink" title="servletConfig拦截器"></a>servletConfig拦截器</h5></li><li>将源于Servlet API的各种对象注入到Action<h5 id="fileUpload拦截器"><a href="#fileUpload拦截器" class="headerlink" title="fileUpload拦截器"></a>fileUpload拦截器</h5></li><li>对文件上传提供支持<h5 id="exception拦截器"><a href="#exception拦截器" class="headerlink" title="exception拦截器"></a>exception拦截器</h5></li><li>捕获异常，并且将异常映射到用户自定义的错误页面<h5 id="validation拦截器"><a href="#validation拦截器" class="headerlink" title="validation拦截器"></a>validation拦截器</h5></li><li>调用验证框架进行数据验证<h5 id="workflow拦截器"><a href="#workflow拦截器" class="headerlink" title="workflow拦截器"></a>workflow拦截器</h5></li><li>调用Action类的validate()，执行数据验证</li></ul><h4 id="Struts2默认拦截器栈"><a href="#Struts2默认拦截器栈" class="headerlink" title="Struts2默认拦截器栈"></a>Struts2默认拦截器栈</h4><ul><li>Struts-default.xml中定义一个defaultStack拦截器栈，并将其指定为默认拦截器</li><li>只要在定义包的过程中继承struts-default包，那么defaultStack将是默认的拦截器</li></ul><h4 id="自定义拦截器"><a href="#自定义拦截器" class="headerlink" title="自定义拦截器"></a>自定义拦截器</h4><h5 id="实现Interceptor接口"><a href="#实现Interceptor接口" class="headerlink" title="实现Interceptor接口"></a>实现Interceptor接口</h5><h6 id="void-init-初始化拦截器所需资源"><a href="#void-init-初始化拦截器所需资源" class="headerlink" title="void init():初始化拦截器所需资源"></a>void init():初始化拦截器所需资源</h6><h6 id="void-destroy-释放在init-中分配的资源"><a href="#void-destroy-释放在init-中分配的资源" class="headerlink" title="void destroy():释放在init()中分配的资源"></a>void destroy():释放在init()中分配的资源</h6><h6 id="String-intercept-Actioninvocation-ai-throws-Exception"><a href="#String-intercept-Actioninvocation-ai-throws-Exception" class="headerlink" title="String intercept(Actioninvocation ai) throws Exception"></a>String intercept(Actioninvocation ai) throws Exception</h6><ul><li>实现拦截器功能</li><li>利用Actionlnvocation参数获取Action状态</li><li>返回结果码（result）字符串</li></ul><h5 id="继承Abstractlnterceptor类"><a href="#继承Abstractlnterceptor类" class="headerlink" title="继承Abstractlnterceptor类"></a>继承Abstractlnterceptor类</h5><ul><li>提供了init()和destroy()方法的空实现</li><li>只需要实现intercept方法即可<br>对比实现interceptor接口推荐使用</li></ul><h4 id="判断用户是否登录"><a href="#判断用户是否登录" class="headerlink" title="判断用户是否登录"></a>判断用户是否登录</h4><h5 id="权限验证拦截器"><a href="#权限验证拦截器" class="headerlink" title="权限验证拦截器"></a>权限验证拦截器</h5><p><img src="/2020/05/15/Struts2%E6%8B%A6%E6%88%AA%E5%99%A8/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_202005151222255.png" srcset="/img/loading.gif" alt="Alt text"></p><h5 id="在配置文件中定义拦截器并引用它"><a href="#在配置文件中定义拦截器并引用它" class="headerlink" title="在配置文件中定义拦截器并引用它"></a>在配置文件中定义拦截器并引用它</h5><p><img src="/2020/05/15/Struts2%E6%8B%A6%E6%88%AA%E5%99%A8/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_202005151222256.png" srcset="/img/loading.gif" alt="Alt text"></p><blockquote><p>本文根据哈尔滨华育兴业教师欧阳广靖老师的课记录</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux运行hadoop提示无权限</title>
    <link href="/2020/05/15/Linux%E8%BF%90%E8%A1%8Chadoop%E6%8F%90%E7%A4%BA%E6%97%A0%E6%9D%83%E9%99%90/"/>
    <url>/2020/05/15/Linux%E8%BF%90%E8%A1%8Chadoop%E6%8F%90%E7%A4%BA%E6%97%A0%E6%9D%83%E9%99%90/</url>
    
    <content type="html"><![CDATA[<h2 id="Linux运行hadoop提示无权限"><a href="#Linux运行hadoop提示无权限" class="headerlink" title="Linux运行hadoop提示无权限"></a><p align="center">Linux运行hadoop提示无权限</p></h2><p align="right">记录人：霖雨成思<blockquote><p>root账户执行指令：chown -R hadoop:hadoop /opt/modules/hadoop-2.7.6(hadoop解压目录)就可以了</p></blockquote></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>OGNL</title>
    <link href="/2020/05/15/OGNL/"/>
    <url>/2020/05/15/OGNL/</url>
    
    <content type="html"><![CDATA[<h2 id="第一个Struts2程序"><a href="#第一个Struts2程序" class="headerlink" title="第一个Struts2程序"></a><p align="center">第一个Struts2程序</p></h2><p align="right">记录人：霖雨成思</p><h4 id="什么是OGNL"><a href="#什么是OGNL" class="headerlink" title="什么是OGNL"></a>什么是OGNL</h4><blockquote><p>Object Graph Navigation Language<br>开源项目，取代页面中Java脚本，简化数据访问<br>和EL同属于表达式语言，但功能更为强大</p></blockquote><h4 id="OGNL在Struts2中做的两件事"><a href="#OGNL在Struts2中做的两件事" class="headerlink" title="OGNL在Struts2中做的两件事"></a>OGNL在Struts2中做的两件事</h4><blockquote><h5 id="表达式语言"><a href="#表达式语言" class="headerlink" title="表达式语言"></a>表达式语言</h5><ul><li>将表单或Struts2标签与特定的Java数据绑定起来，用来数据移入、移出框架<h5 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h5><ul><li>数据进入和流出框架，在页面数据的字符串类型和Java数据类型之间进行转换</li></ul></li></ul></blockquote><h4 id="OGNL融入Struts2"><a href="#OGNL融入Struts2" class="headerlink" title="OGNL融入Struts2"></a>OGNL融入Struts2</h4><h5 id="数据流入"><a href="#数据流入" class="headerlink" title="数据流入"></a>数据流入</h5><h5 id="输入流出"><a href="#输入流出" class="headerlink" title="输入流出"></a>输入流出</h5><p><img src="/2020/05/15/OGNL/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200515095332.png" srcset="/img/loading.gif" alt="Alt text"></p><h4 id="值栈（ValueStack）"><a href="#值栈（ValueStack）" class="headerlink" title="值栈（ValueStack）"></a>值栈（ValueStack）</h4><h5 id="由Struts2框架创建的存储区域，具有栈的特点"><a href="#由Struts2框架创建的存储区域，具有栈的特点" class="headerlink" title="由Struts2框架创建的存储区域，具有栈的特点"></a>由Struts2框架创建的存储区域，具有栈的特点</h5><h5 id="Action的实例会被存放到值栈中"><a href="#Action的实例会被存放到值栈中" class="headerlink" title="Action的实例会被存放到值栈中"></a>Action的实例会被存放到值栈中</h5><h4 id="OGNL访问值栈"><a href="#OGNL访问值栈" class="headerlink" title="OGNL访问值栈"></a>OGNL访问值栈</h4><h5 id="按照从上到下的顺序"><a href="#按照从上到下的顺序" class="headerlink" title="按照从上到下的顺序"></a>按照<strong>从上到下</strong>的顺序</h5><h5 id="靠近栈顶的同名属性会被读取"><a href="#靠近栈顶的同名属性会被读取" class="headerlink" title="靠近栈顶的同名属性会被读取"></a>靠近栈顶的同名属性会被读取</h5><h4 id="内置类型转换器"><a href="#内置类型转换器" class="headerlink" title="内置类型转换器"></a>内置类型转换器</h4><h5 id="Struts2提供了多种内置类型转换器，自动对客户端传来的数据进行类型转换"><a href="#Struts2提供了多种内置类型转换器，自动对客户端传来的数据进行类型转换" class="headerlink" title="Struts2提供了多种内置类型转换器，自动对客户端传来的数据进行类型转换"></a>Struts2提供了多种内置类型转换器，自动对客户端传来的数据进行类型转换</h5><p><img src="/2020/05/15/OGNL/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200515095333.png" srcset="/img/loading.gif" alt="Alt text"><br><img src="/2020/05/15/OGNL/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_202005150953331.png" srcset="/img/loading.gif" alt="Alt text"><br><img src="/2020/05/15/OGNL/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_202005150953332.png" srcset="/img/loading.gif" alt="Alt text"><br><img src="/2020/05/15/OGNL/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_202005150953333.png" srcset="/img/loading.gif" alt="Alt text"></p><h4 id="配置自定义类型转换器"><a href="#配置自定义类型转换器" class="headerlink" title="配置自定义类型转换器"></a>配置自定义类型转换器</h4><h5 id="应用于全局范围的类型转换器"><a href="#应用于全局范围的类型转换器" class="headerlink" title="应用于全局范围的类型转换器"></a>应用于全局范围的类型转换器</h5><h6 id="在src目录下创建xwork-conversion-properties"><a href="#在src目录下创建xwork-conversion-properties" class="headerlink" title="在src目录下创建xwork-conversion.properties"></a>在src目录下创建xwork-conversion.properties</h6><p>[转换类全名=类型转换器全名]</p><h5 id="应用于特定的类型转换器"><a href="#应用于特定的类型转换器" class="headerlink" title="应用于特定的类型转换器"></a>应用于特定的类型转换器</h5><h6 id="在特定类的相同目录下创建一个名为ClassName-conversion-properties的属性文件"><a href="#在特定类的相同目录下创建一个名为ClassName-conversion-properties的属性文件" class="headerlink" title="在特定类的相同目录下创建一个名为ClassName-conversion.properties的属性文件"></a>在特定类的相同目录下创建一个名为ClassName-conversion.properties的属性文件</h6><p>[特定类的属性名=类型转换器类全名]</p><h4 id="处理类型转换错误"><a href="#处理类型转换错误" class="headerlink" title="处理类型转换错误"></a>处理类型转换错误</h4><p><img src="/2020/05/15/OGNL/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_202005150953334.png" srcset="/img/loading.gif" alt="Alt text"></p><h5 id="向用户输出类型转换错误的前提条件"><a href="#向用户输出类型转换错误的前提条件" class="headerlink" title="向用户输出类型转换错误的前提条件"></a>向用户输出类型转换错误的前提条件</h5><h6 id="启动StrutsConversionErrorInterceptor拦截器"><a href="#启动StrutsConversionErrorInterceptor拦截器" class="headerlink" title="启动StrutsConversionErrorInterceptor拦截器"></a>启动StrutsConversionErrorInterceptor拦截器</h6><ul><li>拦截器已经包含在defaultStack拦截器栈中<h5 id="Action要继承ActionSupport类"><a href="#Action要继承ActionSupport类" class="headerlink" title="Action要继承ActionSupport类"></a>Action要继承ActionSupport类</h5></li><li>实质是实现ValidationAware接口<h5 id="配置input结果映射"><a href="#配置input结果映射" class="headerlink" title="配置input结果映射"></a>配置input结果映射</h5><h5 id="页面使用Struts2表单标签或-lt-s-fielderror-gt-标签"><a href="#页面使用Struts2表单标签或-lt-s-fielderror-gt-标签" class="headerlink" title="页面使用Struts2表单标签或&lt;s:fielderror&gt;标签"></a>页面使用Struts2表单标签或<code>&lt;s:fielderror&gt;</code>标签</h5></li><li>Struts2表单标签内嵌了输出错误信息功能</li><li>普通HTML标签需使用<code>&lt;s:fielderror&gt;</code>标签输出转换错误<br><img src="/2020/05/15/OGNL/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_202005150953335.png" srcset="/img/loading.gif" alt="Alt text"><br><img src="/2020/05/15/OGNL/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_202005150953336.png" srcset="/img/loading.gif" alt="Alt text"><h4 id="OGNL-表达式注意事项"><a href="#OGNL-表达式注意事项" class="headerlink" title="OGNL 表达式注意事项"></a>OGNL 表达式注意事项</h4><h5 id="访问Bean的属性"><a href="#访问Bean的属性" class="headerlink" title="访问Bean的属性"></a>访问Bean的属性</h5><h6 id="Bean的类型必须遵循JavaBean规范"><a href="#Bean的类型必须遵循JavaBean规范" class="headerlink" title="Bean的类型必须遵循JavaBean规范"></a>Bean的类型必须遵循JavaBean规范</h6></li><li>必须具有无参构造<h5 id="访问集合对象"><a href="#访问集合对象" class="headerlink" title="访问集合对象"></a>访问集合对象</h5><h6 id="可以使用属性名-index-的方式访问"><a href="#可以使用属性名-index-的方式访问" class="headerlink" title="可以使用属性名[index]的方式访问"></a>可以使用属性名[index]的方式访问</h6></li><li>列表、数组<h6 id="可以使用属性名-key-的方式访问"><a href="#可以使用属性名-key-的方式访问" class="headerlink" title="可以使用属性名[key]的方式访问"></a>可以使用属性名[key]的方式访问</h6></li><li>Map对象<h6 id="使用size或者length获取集合长度"><a href="#使用size或者length获取集合长度" class="headerlink" title="使用size或者length获取集合长度"></a>使用size或者length获取集合长度</h6></li></ul><h5 id="访问JavaBean"><a href="#访问JavaBean" class="headerlink" title="访问JavaBean"></a>访问JavaBean</h5><p><img src="/2020/05/15/OGNL/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_202005150953337.png" srcset="/img/loading.gif" alt="Alt text"></p><h5 id="定义列表"><a href="#定义列表" class="headerlink" title="定义列表"></a>定义列表</h5><p><img src="/2020/05/15/OGNL/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_202005150953338.png" srcset="/img/loading.gif" alt="Alt text"></p><h5 id="定义数组"><a href="#定义数组" class="headerlink" title="定义数组"></a>定义数组</h5><p><img src="/2020/05/15/OGNL/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_202005150953339.png" srcset="/img/loading.gif" alt="Alt text"></p><h5 id="定义Map"><a href="#定义Map" class="headerlink" title="定义Map"></a>定义Map</h5><p><img src="/2020/05/15/OGNL/aa6cfe8d1cadb382378bfa3011357f2.png" srcset="/img/loading.gif" alt="Alt text"></p><h4 id="Struts2下使用OGNL"><a href="#Struts2下使用OGNL" class="headerlink" title="Struts2下使用OGNL"></a>Struts2下使用OGNL</h4><h5 id="访问非值栈对象"><a href="#访问非值栈对象" class="headerlink" title="访问非值栈对象"></a>访问非值栈对象</h5><p><img src="/2020/05/15/OGNL/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_2020051509533310.png" srcset="/img/loading.gif" alt="Alt text"><br><img src="/2020/05/15/OGNL/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_2020051509533311.png" srcset="/img/loading.gif" alt="Alt text"></p><pre><code class="xml">&lt;s:set name=&quot;age&quot; value=&quot;10&quot; scope=&quot;request&quot;/&gt;&lt;s:set name=&quot;username&quot; value=&quot;&#39;Jason&#39;&quot; scope=&quot;session&quot;/&gt;&lt;s:set name=&quot;count&quot; value=&quot;5&quot; scope=&quot;application&quot;/&gt;        #request.age:&lt;s:property value=&quot;#request.age&quot;/&gt;&lt;br/&gt;#session.username:&lt;s:property value=&quot;#session.username&quot;/&gt;&lt;br/&gt;#application.count:&lt;s:property value=&quot;#application.count&quot;/&gt;&lt;br/&gt;#attr.count:&lt;s:property value=&quot;#attr.count&quot; /&gt;&lt;br /&gt;    &lt;s:set name=&quot;country1&quot; value=&quot;China&quot;/&gt;    &lt;s:set name=&quot;country2&quot; value=&quot;&#39;China&#39;&quot;/&gt;#country1:&lt;s:property value=&quot;#country1&quot;/&gt;&lt;br/&gt;#country2:&lt;s:property value=&quot;#country2&quot;/&gt;&lt;br/&gt;    #request.country2:&lt;s:property value=&quot;#request.country2&quot;/&gt;&lt;br/&gt;</code></pre><h4 id="使用-lt-s-debug-gt-查看数据"><a href="#使用-lt-s-debug-gt-查看数据" class="headerlink" title="使用&lt;s:debug/&gt;查看数据"></a>使用<code>&lt;s:debug/&gt;</code>查看数据</h4><h5 id="ActionContext的组成"><a href="#ActionContext的组成" class="headerlink" title="ActionContext的组成"></a>ActionContext的组成</h5><ul><li>值栈-ValueStack</li><li>非值栈-Stack Context<h4 id="Struts2标签的属性类型"><a href="#Struts2标签的属性类型" class="headerlink" title="Struts2标签的属性类型"></a>Struts2标签的属性类型</h4><img src="/2020/05/15/OGNL/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_2020051509533312.png" srcset="/img/loading.gif" alt="Alt text"><h4 id="URL标签"><a href="#URL标签" class="headerlink" title="URL标签"></a>URL标签</h4><img src="/2020/05/15/OGNL/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_2020051509533312.png" srcset="/img/loading.gif" alt="Alt text"><h4 id="日期标签"><a href="#日期标签" class="headerlink" title="日期标签"></a>日期标签</h4><img src="/2020/05/15/OGNL/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_2020051509533313.png" srcset="/img/loading.gif" alt="Alt text"></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote><p>Struts 2提供了非常强大的类型转换功能，提供了多种内置类型转换器，也支持开发自定义类型转换器<br>Struts 2框架使用OGNL作为默认的表达式语言<br>ActionContext中包含多个对象。如果使用OGNL访问根对象，可直接书写对象的属性，而要使用其他对象必须使用“#key”前缀来访问<br>使用Struts 2日期标签可以实现日期输出的格式化显示，使用URL标签可以构建一个超链接<br><img src="/2020/05/15/OGNL/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_2020051509533314.png" srcset="/img/loading.gif" alt="Alt text"></p></blockquote><blockquote><p>本文根据哈尔滨华育兴业教师欧阳广靖老师的课记录</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Strust2入门</title>
    <link href="/2020/04/28/Strust2%E5%85%A5%E9%97%A8/"/>
    <url>/2020/04/28/Strust2%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="第一个Struts2程序"><a href="#第一个Struts2程序" class="headerlink" title="第一个Struts2程序"></a><p align="center">第一个Struts2程序</p></h2><p align="right">记录人：霖雨成思</p><h4 id="加载Struts2类库（导包）"><a href="#加载Struts2类库（导包）" class="headerlink" title="加载Struts2类库（导包）"></a>加载Struts2类库（导包）</h4><p><img src="/2020/04/28/Strust2%E5%85%A5%E9%97%A8/jar1.png" srcset="/img/loading.gif" alt="Alt text"><br><img src="/2020/04/28/Strust2%E5%85%A5%E9%97%A8/jar2.png" srcset="/img/loading.gif" alt="Alt text"></p><h4 id="配置web-xml文件"><a href="#配置web-xml文件" class="headerlink" title="配置web.xml文件"></a>配置web.xml文件</h4><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:web=&quot;http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; version=&quot;3.0&quot;&gt;  &lt;filter&gt;    &lt;filter-name&gt;struts2&lt;/filter-name&gt;    &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;  &lt;/filter&gt;  &lt;filter-mapping&gt;    &lt;filter-name&gt;struts2&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;!--将全部请求定位到指定的Struts2过滤器中--&gt;  &lt;/filter-mapping&gt;  &lt;welcome-file-list&gt;    &lt;welcome-file&gt;/helloWorld.jsp&lt;/welcome-file&gt;  &lt;/welcome-file-list&gt;&lt;/web-app&gt;</code></pre><h4 id="开发视图层页面（前台）"><a href="#开发视图层页面（前台）" class="headerlink" title="开发视图层页面（前台）"></a>开发视图层页面（前台）</h4><p>编写输出页面helloWorld.jsp</p><pre><code class="jsp">&lt;body&gt;${message}&lt;br&gt;&lt;!-- 与定影的action文件属性一致 --&gt;&lt;!-- 与Struts.xml配置文件中，action标签的name值一致 --&gt;&lt;form action=&quot;helloWorld.action&quot; method=&quot;post&quot;&gt;&lt;!-- input标签的name值与action的属性名一致 --&gt;用户名:&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt;密    码:&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;</code></pre><h4 id="开发控制层Action"><a href="#开发控制层Action" class="headerlink" title="开发控制层Action"></a>开发控制层Action</h4><p>编写HelloWorldAction</p><pre><code class="java">public class HelloWorldAction implements Action {    // 用户输入的姓名    private String name = &quot;&quot;;    // 向用户显示的信息    private String message = &quot;&quot;;    public String execute() {        // 根据用户输入的姓名,进行&quot;Hello,XXXX!&quot;的封装        this.setMessage(&quot;Hello,&quot;+this.getName()+&quot;!&quot;);        // 处理完毕,返回导航结果的逻辑名        return &quot;success&quot;;    }    ……    //省略setter、getter方法}或import com.opensymphony.xwork2.Action;public class HelloStrutsAction implements Action{    //获取页面数据    private String username;    private String password;    //传值到页面的数据    private String message;    @Override    public String execute() throws Exception {        if(username.equals(&quot;admin&quot;)&amp;&amp;password.equals(&quot;123456&quot;)){            message=username+&quot;,欢迎您&quot;;        }else{            message = username+&quot;,您的用户名或密码不正确&quot;;        }        return &quot;success&quot;;//与Struts.xml文件的action的result标签的name一致    }    ……    //省略setter、getter方法</code></pre><h4 id="配置struts-xml文件"><a href="#配置struts-xml文件" class="headerlink" title="配置struts.xml文件"></a>配置struts.xml文件</h4><pre><code>&lt;struts&gt;    &lt;!-- 创建一个default包，继承自Struts2的struts-default包 --&gt;    &lt;package name=&quot;default&quot; namespace=&quot;/&quot; extends=&quot;struts-default&quot;&gt;        &lt;!-- 接收处理用户的/helloWorld.action请求 ，并根据返回结果，完成 跳转            name与页面的 请求地址一致，class是处理的action类全路径--&gt;        &lt;action name=&quot;helloWorld&quot; class=&quot;com.hib.action.HelloStrutsAction&quot;&gt;            &lt;!-- 结果为&quot;helloWorld&quot;时，跳转至helloWorld.jsp页面 --&gt;            &lt;result name=&quot;success&quot;&gt;helloWorld.jsp&lt;/result&gt;        &lt;/action&gt;        &lt;action name=&quot;login&quot; class=&quot;com.hib.action.LoginAction&quot;&gt;            &lt;!-- 结果为&quot;success&quot;时，跳转至success.jsp页面 --&gt;            &lt;result name=&quot;success&quot;&gt;enter.jsp&lt;/result&gt;            &lt;!-- 结果为&quot;error&quot;时，跳转至login.jsp页面 --&gt;            &lt;result name=&quot;faile&quot;&gt;login.jsp&lt;/result&gt;            &lt;result name=&quot;input&quot;&gt;login.jsp&lt;/result&gt;        &lt;/action&gt;    &lt;/package&gt;&lt;/struts&gt;</code></pre><p><img src="/2020/04/28/Strust2%E5%85%A5%E9%97%A8/Struts.xml.png" srcset="/img/loading.gif" alt="Alt text"></p><p>####部署、运行项目</p><p>####如果登录成功，如果使用session保存用户信息</p><p>Struts2访问Servlet API的方式</p><ul><li>与Servlet API解耦的访问方式</li></ul><p><img src="/2020/04/28/Strust2%E5%85%A5%E9%97%A8/jieou.png" srcset="/img/loading.gif" alt="Alt text"></p><p>页面显示<br><img src="/2020/04/28/Strust2%E5%85%A5%E9%97%A8/xianshi.png" srcset="/img/loading.gif" alt="Alt text"></p><ul><li>与Servlet API耦合的访问方式</li></ul><p><img src="/2020/04/28/Strust2%E5%85%A5%E9%97%A8/ouhe.png" srcset="/img/loading.gif" alt="Alt text"></p><h4 id="如何对用户登录添加表单验证功能"><a href="#如何对用户登录添加表单验证功能" class="headerlink" title="如何对用户登录添加表单验证功能"></a>如何对用户登录添加表单验证功能</h4><blockquote><p>Struts2提供了数据验证机制</p></blockquote><ul><li>继承ActionSupport类来完成Action开发</li><li>ActionSupport类不仅对Action接口进行简单实现，同时还增加了验证、本地化等支持</li></ul><p><img src="/2020/04/28/Strust2%E5%85%A5%E9%97%A8/xiugai.png" srcset="/img/loading.gif" alt="Alt text"></p><h4 id="如何将Action的错误信息在页面输出？"><a href="#如何将Action的错误信息在页面输出？" class="headerlink" title="如何将Action的错误信息在页面输出？"></a>如何将Action的错误信息在页面输出？</h4><blockquote><p>使用Struts2提供的标签来完成<br>Struts2标签分为UI标签和通用标签</p></blockquote><pre><code>&lt;%@ taglib prefix=&quot;s&quot; uri=&quot;/struts-tags&quot;%&gt;![Alt text](./1588059221987.png) &lt;!--需要在页面中引入Struts2的标签库--&gt;</code></pre><h5 id="常用表单标签"><a href="#常用表单标签" class="headerlink" title="常用表单标签"></a>常用表单标签</h5><p><img src="/2020/04/28/Strust2%E5%85%A5%E9%97%A8/biaodan1.png" srcset="/img/loading.gif" alt="Alt text"></p><h5 id="常用非表单标签"><a href="#常用非表单标签" class="headerlink" title="常用非表单标签"></a>常用非表单标签</h5><p><img src="/2020/04/28/Strust2%E5%85%A5%E9%97%A8/biaodan2.png" srcset="/img/loading.gif" alt="Alt text"></p><h4 id="修改jsp页面"><a href="#修改jsp页面" class="headerlink" title="修改jsp页面"></a>修改jsp页面</h4><p><img src="/2020/04/28/Strust2%E5%85%A5%E9%97%A8/xiugai2.png" srcset="/img/loading.gif" alt="Alt text"></p><h4 id="使用Struts2标签是否可以在页面中实现逻辑控制？"><a href="#使用Struts2标签是否可以在页面中实现逻辑控制？" class="headerlink" title="使用Struts2标签是否可以在页面中实现逻辑控制？"></a>使用Struts2标签是否可以在页面中实现逻辑控制？</h4><blockquote><p>使用Struts2的通用标签</p></blockquote><ul><li>条件判断标签</li><li>迭代标签</li></ul><h5 id="常用通用标签"><a href="#常用通用标签" class="headerlink" title="常用通用标签"></a>常用通用标签</h5><p><img src="/2020/04/28/Strust2%E5%85%A5%E9%97%A8/changyongtongyong.png" srcset="/img/loading.gif" alt="Alt text"></p><p><img src="/2020/04/28/Strust2%E5%85%A5%E9%97%A8/tiaojianpanduan.png" srcset="/img/loading.gif" alt="Alt text"></p><p><img src="/2020/04/28/Strust2%E5%85%A5%E9%97%A8/iterator.png" srcset="/img/loading.gif" alt="Alt text"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="/2020/04/28/Strust2%E5%85%A5%E9%97%A8/zongjie.png" srcset="/img/loading.gif" alt="Alt text"></p><blockquote><p>本文根据哈尔滨华育兴业教师欧阳广靖老师的课记录</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>在电脑中建立虚拟域名并绑定项目</title>
    <link href="/2020/04/12/%E5%9C%A8%E7%94%B5%E8%84%91%E4%B8%AD%E5%BB%BA%E7%AB%8B%E8%99%9A%E6%8B%9F%E5%9F%9F%E5%90%8D%E5%B9%B6%E7%BB%91%E5%AE%9A%E9%A1%B9%E7%9B%AE/"/>
    <url>/2020/04/12/%E5%9C%A8%E7%94%B5%E8%84%91%E4%B8%AD%E5%BB%BA%E7%AB%8B%E8%99%9A%E6%8B%9F%E5%9F%9F%E5%90%8D%E5%B9%B6%E7%BB%91%E5%AE%9A%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="在电脑中建立虚拟域名并绑定项目"><a href="#在电脑中建立虚拟域名并绑定项目" class="headerlink" title="在电脑中建立虚拟域名并绑定项目"></a><p align="center">在电脑中建立虚拟域名并绑定项目</p></h2><p align="right">记录人：霖雨成思</p><h4 id="Windows下使用Apache配置多域名的方法"><a href="#Windows下使用Apache配置多域名的方法" class="headerlink" title="Windows下使用Apache配置多域名的方法"></a>Windows下使用Apache配置多域名的方法</h4><p>1、修改C:\Windows\System32\drivers\etc目录下的hosts文件<br>127.0.0.1（本机）    shop.top（域名）</p><blockquote><p>“#代表注释”</p></blockquote><p>2、修改D:\phpStudy\Apache\conf (这个目录不固定）目录下的httpd.conf文件,去掉前面的#<br><img src="/2020/04/12/%E5%9C%A8%E7%94%B5%E8%84%91%E4%B8%AD%E5%BB%BA%E7%AB%8B%E8%99%9A%E6%8B%9F%E5%9F%9F%E5%90%8D%E5%B9%B6%E7%BB%91%E5%AE%9A%E9%A1%B9%E7%9B%AE/1.png" srcset="/img/loading.gif" alt="Alt text"></p><p>3、修改D:\phpStudy\Apache\extra (这个目录不固定）目录下的httpd-vhosts.conf文件,添加以下内容</p><pre><code>&lt;/VirtualHost&gt;&lt;VirtualHost *:80&gt; #如果更改默认端口号，则写更改后的端口DocumentRoot &quot;你的项目名&quot;   ServerName 你的域名  &lt;/VirtualHost&gt;</code></pre><p>4、重启服务器，访问域名，自然就回访问到你的项目</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hibernate简单配置——实现增删改查</title>
    <link href="/2020/04/04/Hibernate%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5-0/"/>
    <url>/2020/04/04/Hibernate%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5-0/</url>
    
    <content type="html"><![CDATA[<p align="center">hibernate简单配置——实现增删改查</p><p align="right">记录人：霖雨成思</p><p>2020年4月4日 清明节<br>写这篇博客之前想说<br>今天是清明节，为表达全国各族人民对抗击新冠肺炎疫情斗争牺牲烈士和逝世同胞的深切哀悼，国务院决定2020年4月4日举行全国性哀悼活动为表达全国各族人民对抗击新冠肺炎疫情斗争牺牲烈士和逝世同胞的深切哀悼，国务院决定2020年4月4日举行全国性哀悼活动<br>愿逝者安息，愿生者奋发，愿祖国昌盛</p><blockquote><p>hibernate极大的简化了JDBC繁琐的编码<br>对面向对象特性支持良好<br>可移植性好</p></blockquote><h3 id="hibernate的步骤使用"><a href="#hibernate的步骤使用" class="headerlink" title="hibernate的步骤使用"></a>hibernate的步骤使用</h3><ul><li>现在并部署jar文件</li><li>编写hibernate配置文件</li><li>创建持久化类和映射文件</li><li>使用hibernate API</li></ul><h3 id="部署jar文件"><a href="#部署jar文件" class="headerlink" title="部署jar文件"></a>部署jar文件</h3><h5 id="下载需要的jar文件"><a href="#下载需要的jar文件" class="headerlink" title="下载需要的jar文件"></a>下载需要的jar文件</h5><p>Hibernate的官方网站<a href="http://hibernate.org" target="_blank" rel="noopener">http://hibernate.org</a><br>托管网站<a href="https://sourceforge.net/projects/hibernate/files/" target="_blank" rel="noopener">https://sourceforge.net/projects/hibernate/files/</a><br>推荐下载：hibernate-distribution-3.6.10.Final-dist.zip</p><h5 id="部署jar文件-1"><a href="#部署jar文件-1" class="headerlink" title="部署jar文件"></a>部署jar文件</h5><p>hibernate3.jar<br>hibernate需要的相关jar文件<br>mysql数据库驱动jar文件</p><h3 id="编写hibernate配置文件-一般命名为hibernate-cfg-xml"><a href="#编写hibernate配置文件-一般命名为hibernate-cfg-xml" class="headerlink" title="编写hibernate配置文件(一般命名为hibernate.cfg.xml)"></a>编写hibernate配置文件(一般命名为hibernate.cfg.xml)</h3><pre><code class="xml">&lt;?xml version=&#39;1.0&#39; encoding=&#39;utf-8&#39;?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC    &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot;    &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;&lt;hibernate-configuration&gt;    &lt;session-factory&gt;        &lt;!-- 数据库URL:localhost是本机的地址，3306是MySQL默认端口号，house是数据库名 --&gt;        &lt;property name=&quot;connection.url&quot;&gt;            jdbc:mysql://localhost:3306/house        &lt;/property&gt;        &lt;!--  数据库用户  --&gt;        &lt;property name=&quot;connection.username&quot;&gt;root&lt;/property&gt;        &lt;!--  数据库用户密码  --&gt;        &lt;property name=&quot;connection.password&quot;&gt;root&lt;/property&gt;        &lt;!-- 数据库JDBC驱动   --&gt;        &lt;property name=&quot;connection.driver_class&quot;&gt;            com.mysql.jdbc.Driver        &lt;/property&gt;        &lt;!--  每个数据库都有其对应的Dialect以匹配其平台特性   hibernate根据平台写SQL  --&gt;        &lt;property name=&quot;dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;        &lt;!--  指定当前session范围和上下文   当提交以后session自动关闭--&gt;        &lt;property name=&quot;current_session_context_class&quot;&gt;thread&lt;/property&gt;        &lt;!--  是否将运行期生成的SQL输出到日志以供调试   --&gt;        &lt;property name=&quot;show_sql&quot;&gt;true&lt;/property&gt;        &lt;!--   是否格式化SQL   --&gt;        &lt;property name=&quot;format_sql&quot;&gt;true&lt;/property&gt;                &lt;!--    加载映射文件资源，资源包中间用/例如：dao/Users.hbm.xml   --&gt;        &lt;mapping resource=&quot;dao/Users.hbm.xml&quot;/&gt;    &lt;/session-factory&gt;&lt;/hibernate-configuration&gt;</code></pre><blockquote><p>我在向数据库输出中文内容时，出现乱码行为，在上边的配置文件中的数据库后边加上:</p></blockquote><pre><code>?Unicode=true&amp;amp;characterEncoding=GBK </code></pre><h3 id="创建持久化类和映射文件"><a href="#创建持久化类和映射文件" class="headerlink" title="创建持久化类和映射文件"></a>创建持久化类和映射文件</h3><pre><code class="java">public class Users {    //Users封装类    private int eid;    private String ename;    。。。省略getter和setter方法</code></pre><p>···</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC     &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;    &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping&gt;    &lt;!-- name是class的路径  table为表名（如果是关键字，用``括上  dynamic-update动态修改 --&gt;    &lt;!-- 映射文类和表，class中的class是实体类（持久化类）名字 --&gt;    &lt;class name=&quot;Users&quot; table=&quot;users&quot; dynamic-update=&quot;true&quot;&gt;        &lt;!-- name实体类属性名   column是表中的字段名  --&gt;        &lt;id name=&quot;eid&quot; type=&quot;java.lang.Integer&quot; column=&quot;id&quot; &gt;        &lt;!-- class自增，设置完后数据库可以不用设置自增 （主键生成策略）native为数据库中字段已设置自增--&gt;            &lt;generator class=&quot;assigned&quot;/&gt;        &lt;/id&gt;         &lt;!-- column数据库表里的列名 --&gt;        &lt;property name=&quot;ename&quot; type=&quot;java.lang.String&quot; column=&quot;name&quot;/&gt;    &lt;/class&gt;&lt;/hibernate-mapping&gt;</code></pre><p>注意：数据库使用主键生成器不要使用assigned</p><h3 id="使用hibernate-API"><a href="#使用hibernate-API" class="headerlink" title="使用hibernate API"></a>使用hibernate API</h3><pre><code class="java">import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.hibernate.cfg.Configuration;import org.junit.Test;public class Tests {    //开启事物    public static Session Trans(){        //读取xml文件                Configuration conf = new Configuration().configure();                //创建session工厂                SessionFactory sessionFactory = conf.buildSessionFactory();                //获取session                Session session = sessionFactory.getCurrentSession();                return session;    }    //添加方法    @Test    public void add(){        System.out.println(&quot;添加方法&quot;);        Session session = Tests.Trans();        //开启事物        Transaction trans = session.beginTransaction();        //实例化对象        Users u = new Users();//临时状态        u.setEid(3);        u.setEname(&quot;王五&quot;);        session.save(u);//持久状态        trans.commit();//提交    }    //删除方法    @Test    public void del(){        System.out.println(&quot;删除方法&quot;);        Session session = Tests.Trans();        Transaction trans = session.beginTransaction();        //实例化对象        Users u = new Users();//临时状态        u.setEid(3);        session.delete(u);        trans.commit();    }    //修改方法1：只修改写入的属性    @Test    public void update1(){        System.out.println(&quot;修改方法1&quot;);        Session session = Tests.Trans();        //开启事物        Transaction trans = session.beginTransaction();        Users u = (Users) session.get(Users.class, 1);//直接转换为持久态        u.setEname(&quot;张小三&quot;);        trans.commit();//提交的时候，如果u与数据库不一致，则执行update        System.out.println(u);//游离态    }     //修改方法2：全部修改，如果没写，则数据库对应属性为空    @Test    public void update2(){        System.out.println(&quot;修改方法2&quot;);        Session session = Tests.Trans();        Transaction trans = session.beginTransaction();        Users u = new Users();        u.setEid(2);        u.setTelephone(&quot;13222223333&quot;);        session.update(u);        trans.commit();    }    //修改方法3 :全部修改，如果没写，则数据库对应属性为空    @Test    public void update3(){        System.out.println(&quot;修改方法3&quot;);        Session session = Tests.Trans();        Transaction trans = session.beginTransaction();        Users u = new Users();        u.setEid(2);        u.setEname(&quot;李四&quot;);        session.merge(u);        trans.commit();    }    //修改方法4:全部修改 ，如果没写，则对应属性为空    @Test    public void update4(){        System.out.println(&quot;修改方法4&quot;);        Session session = Tests.Trans();        Transaction trans = session.beginTransaction();        Users u = new Users();        u.setEid(3);        u.setEname(&quot;王小五&quot;);        u.setTelephone(&quot;13299998888&quot;);        session.saveOrUpdate(u);        trans.commit();    }    //按主键查询load 如果没有记录则抛出异常        @Test        public void load(){            System.out.println(&quot;load查询&quot;);            Session session = Tests.Trans();            Transaction trans = session.beginTransaction();            //按主键查找数据,load:第一个参数时要查询的镖所对应的实体类，第二个参数时主键值            //当数据库有该主键值得记录时，返回一个对象            //当数据库中没有该主键值得记录时，抛出异常            Users u = (Users)session.load(Users.class, 1);            System.out.println(u);            //事物提交            trans.commit();        }        //按主键查询get 如果没有记录返回null        @Test        public void get(){            System.out.println(&quot;get查询&quot;);            Session session = Tests.Trans();            Transaction trans = session.beginTransaction();            //按主键查找数据,load:第一个参数时要查询的镖所对应的实体类，第二个参数时主键值            //当数据库有该主键值得记录时，返回一个对象            //当数据库中没有该主键值得记录时，返回null            Users u = (Users)session.get(Users.class, 1);            System.out.println(u);            //事物提交            trans.commit();        }}</code></pre><blockquote><p>SessionFactory无须反复创建</p></blockquote><hr><h4 id="附"><a href="#附" class="headerlink" title="附:"></a>附:</h4><h5 id="4种修改方法（-我在生成内容时，记录了修改的四种方法不同之处，仅表示个人见解，具体方法见上述代码）"><a href="#4种修改方法（-我在生成内容时，记录了修改的四种方法不同之处，仅表示个人见解，具体方法见上述代码）" class="headerlink" title="4种修改方法（ 我在生成内容时，记录了修改的四种方法不同之处，仅表示个人见解，具体方法见上述代码）"></a>4种修改方法（ 我在生成内容时，记录了修改的四种方法不同之处，仅表示个人见解，具体方法见上述代码）</h5><ul><li>方法1：只修改写入的属性 未写的属性不变</li><li>方法2：update 直接修改全部的属性 如果没写 则数据库对应属性为空</li><li>方法3：merge 全部修改 如果没写 则数据库对应属性为空（与方法2不同的是，merge方法先select一遍）</li><li>方法4：有则修改 无则保存 全部修改 如果没写 则数据库对应属性为空 与方法3一致，修改之前先select一遍</li></ul><h5 id="2种查询方法（load、get）"><a href="#2种查询方法（load、get）" class="headerlink" title="2种查询方法（load、get）"></a>2种查询方法（load、get）</h5><p>代码见上述<br>-Object get（Class clazz,Serializable id）若数据不存在，返回null<br>-Object load（Class clazz，Serializable id）若数据不存在，使用时抛出ObjectNotFoundException</p><h5 id="hibernate中Java对象的三种状态"><a href="#hibernate中Java对象的三种状态" class="headerlink" title="hibernate中Java对象的三种状态"></a>hibernate中Java对象的三种状态</h5><ul><li>瞬时状态（Transient）</li><li>持久状态（Persistent）</li><li>游离状态（Detached）</li></ul><p><img src="/2020/04/04/Hibernate%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5-0/29bd6dc17a3dcd8c3b44326ddd469da.png" srcset="/img/loading.gif" alt="Alt text"></p><p><img src="/2020/04/04/Hibernate%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5-0/2.png" srcset="/img/loading.gif" alt="Alt text"></p><h5 id><a href="#" class="headerlink" title></a></h5><p>最后附两张总结图片<br><img src="/2020/04/04/Hibernate%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5-0/43ecc9704a7166ac984f0122c270122.png" srcset="/img/loading.gif" alt="Alt text"><br><img src="/2020/04/04/Hibernate%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5-0/cde213aa384bd76f1c33fc83283ce76.png" srcset="/img/loading.gif" alt="Alt text"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux命令——系统信息类命令</title>
    <link href="/2020/03/24/Linux%E5%91%BD%E4%BB%A4%E2%80%94%E2%80%94%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E7%B1%BB%E5%91%BD%E4%BB%A4/"/>
    <url>/2020/03/24/Linux%E5%91%BD%E4%BB%A4%E2%80%94%E2%80%94%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E7%B1%BB%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="Linux命令-系统信息类命令"><a href="#Linux命令-系统信息类命令" class="headerlink" title="Linux命令-系统信息类命令"></a><p align="center">Linux命令-系统信息类命令</p></h2><p align="right">记录人：霖雨成思</p><h3 id="系统信息类命令"><a href="#系统信息类命令" class="headerlink" title="系统信息类命令"></a>系统信息类命令</h3><p>dmesg:作用是用来显示系统各种硬件的信息<br>df:显示磁盘中每个分区的空间使用情况（加上-h，页面会更直观）<br>du命令：列出当前目录下的每个子目录使用过的磁盘情况（加上-h，页面会更直观）<br>free:查看内存以及交换分区的使用情况（swap是Linux中的一个交换分区，相当于虚拟内存）<br>date：显示系统当前的日期和时间（不带参数）<br>cal（calendar）:默认会输出本月的月历<br>clock：获取从计算机硬件获取时间</p><h3 id="进程管理命令"><a href="#进程管理命令" class="headerlink" title="进程管理命令"></a>进程管理命令</h3><p>ps(process state):默认终端下默认用户的进程<br>终止进程:ps -a获取进程号，kill (参数-9 终止kill无法直接终止的进程)进程号 命令终止<br>renice:root用户修改进程优先级 用法：renice 优先级 进程号 （NI值修改后，系统会更改PRI值）<br>nice:生成一个进程的同时可以设定优先级 用法：nice -优先级 进程命令<br>top:实时监控系统的状态，默认情况下，每5秒钟刷新一次</p><h3 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h3><p>clear:清屏<br>uname:显示系统信息<br>man(manual):查看命令的使用手册<br>shutdown:root用户关机，使用必须带参数(-h now 立即关闭)<br>poweroff:和shutdown -h now 等效<br>reboot:重启系统<br>alias:起命令的别名 取消:unalias 如果有空格，用双引号将整条命令引起来<br>history:查看最近使用的命令记录(环境变量默认最多1000条)</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux命令——文件目录类命令</title>
    <link href="/2020/03/19/Linux%E5%91%BD%E4%BB%A4%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%B1%BB%E5%91%BD%E4%BB%A4/"/>
    <url>/2020/03/19/Linux%E5%91%BD%E4%BB%A4%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%B1%BB%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="Linux命令-文件目录命令"><a href="#Linux命令-文件目录命令" class="headerlink" title="Linux命令-文件目录命令"></a><p align="center">Linux命令-文件目录命令</p></h2><p align="right">记录人：霖雨成思</p><h3 id="命令基础"><a href="#命令基础" class="headerlink" title="命令基础"></a>命令基础</h3><p>Linux命令是严格区分大小写的，<br>登录后会显示一个Shell提示符，普通用户的提示符是$，root用户的提示符是#；<br>查看日期时间：date<br>队列：可以一次提交多条命令，命令之间用分号（;）隔开，Linux会依次执行<br>清屏：clear<br>强制换行：先输入反斜杠（\）再回车<br>输出：echo“ ”<br>查找文件：find / -size +50M（表示在根目录查找文件大小为大于50M的文件）<br>例如:find  -name、文件路径或类型(-type f 表示类型必须是普通文件)<br>例如:把文件找出来删掉:find / -size +100M -type f -exec rm -rf {} ; (-exec是执行的意思，找到某些符合条件的命令后，执行后面的命令    {};代表的是我们找到的这个对象  具体执行的命令是用rm把他删掉，然后用rf选项的作用是强制递归)<br>命令置于后台：命令后加一个&amp;</p><h4 id="文件目录类命令"><a href="#文件目录类命令" class="headerlink" title="文件目录类命令"></a>文件目录类命令</h4><p>列出某个目录下文件的信息：ls （-l长格式输出）（-a显示隐藏文件）（–help获取该命令的帮助）（-R目录递归通过）（-ld目录和符号链接信息）</p><h3 id="文件目录命令1"><a href="#文件目录命令1" class="headerlink" title="文件目录命令1"></a>文件目录命令1</h3><p>列出当前工作路径的命令：pwd<br>改变工作路径：cd（..访问父目录；.当前目录）<br>显示文本文件的内容：cat（适用于查看小文件）<br>输出重定向（在其他文件中查看制定目录）：文件名 &gt; 文件名（如果不存在自动创建，已经存在则会覆盖里面的内容，&gt;&gt;表示追加内容；相当于复制了一份）<br>    如果没有输入被输出文件，则会进入键盘输入制定内容，Ctrl+D提交（优点：快速创建小文件）<br>查看内容较长的文件：more +50（回车下一行，空格切一页，50行为一页，只能向下翻页）<br>查看文件：less（可以上下左右翻页，按Q键退出）<br>显示文件前若干行：head 5（前5行）<br>显示文件后若干行：tail 5（后5行）<br>创建目录：mkdir -p a/b/c（-p表示创建多层目录，abc为想要创建的目录）<br>删除空目录：rmdir（必须为空目录，与mkdir作用反之，方法相同）<br>复制文件：cp a b（必须有两个参数）<br>复制目录：cp -R a b<br>剪切、重命名文件（移动文件）：mv a b<br>i选项：执行询问（输入y回车表示确定，反之为n）<br>f选项：强制操作<br>r选项：递归<br>删除文件：rm</p><blockquote><p>注意：rm -rf /千万不要执行，尤其使用root账户，这个命令会将你的Linux系统根分区全部清空（格式化）<br>快速创建一个新文件：touch（如果后面的参数对应的文件不存在，就快速创建这个文件，如果这个文件已经存在了则把它的修改时间更新为当前的时间）<br>比较两个文件的区别：diff</p></blockquote><hr><p><strong>硬链接</strong><br>创建链接：ln（默认每个文件链接数初始为1）</p><blockquote><p>链接数：是指向磁盘上这个文件数据存储位置的逻辑上的文件名的个数<br>例如：ln b c 表示为b文件创建一个链接为c，此时b文件的链接数由1变为2，而同时多了一个c文件，c的链接数也是2<br>ln命令默认创建的是硬链接，也就是说，b和c对应磁盘上同一块空间，只是逻辑上是两个文件，但在物理磁盘上，是同一块空间<br>此时删除c，b不会有影响，但指向这个逻辑磁盘数少了一个，链接数由2变为1<br><strong>软链接</strong><br>创建链接：ln -s b c（符号链接/软链接）<br>创建后，b的链接数还是1，此时c文件是一个符号链接文件<br>c删掉后，b也不会受到影响<br>所谓符号链接，有点像Windows系统中的创建快捷方式</p></blockquote><h3 id="文件目录命令2"><a href="#文件目录命令2" class="headerlink" title="文件目录命令2"></a>文件目录命令2</h3><p>压缩文件命令：gzip -v（表示显示压缩详情信息）压缩后替代原始文件<br>解压文件命令：gunzip -v（表示显示解压详情信息）解压后替代原始文件<br>目录不能压缩，首先需要归档（就是打包，即把它变成一个普通文件，对应的文件扩展名是.tar）<br>在Windows中，文件夹解压可以直接操作，但在Linux下需要分两步：先（tar）归档，再gzip（压缩）<br>z调用gzip；<br>c，create创建归档文件；<br>f，制定file文件名<br>v，view查看信息<br>通常zcvf一起用（tar -zcvf 文件夹），我们从网上下载的Linux文件很多都是.tar.gz这种格式的，意味着都是对目录先归档再压缩生成的。tar -zxvf还原<br>使用RPM命令安装软件包：</p><blockquote><p>软件仓库<br>yum install 软件名称</p></blockquote><blockquote><p>RPM：RedHat Package Manage红帽软件包管理<br>在官网下载相应软件后，deb适用Ubuntu系统，我用的是centos，所以选rpm<br>通常安装命令：rpm -ivh 文件<br>查询软件包安装信息 rpm -qa(把所有已经安装的软件包信息列出来）<br>产看软件包现在是否已经安装：<br>管道操作：“|”叫做管道符，管道的意思是说：把前面命令执行的输出，作为后面命令的输入，相当于一个管子把他们对接了起来<br>grep用来找一个文件里面查找指定的<strong>关键字</strong>，有的话把对应的行显示出来(-n 表示把关键字的前后n行一并显示)<br>查看系统是否安装某个软件包：rpm -qa  软件<br>删除软件包：rpm -e 软件包名<br>查询命令：–help（善于查参数或选项）<br>          man 命令（善于查函数）</p></blockquote><h3 id="文件目录命令3"><a href="#文件目录命令3" class="headerlink" title="文件目录命令3"></a>文件目录命令3</h3><p>列出<strong>命令</strong>在当前系统中磁盘位置的命令:whertis<br>列出某个命令的一句话的介绍:whatis (不是每个程序都有whatis的命令解释)<br>详细说明：–”help”</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux命令——基础</title>
    <link href="/2020/03/17/Linux%E5%91%BD%E4%BB%A4%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/03/17/Linux%E5%91%BD%E4%BB%A4%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a><p align="center">Linux命令</p></h2><h3 id="命令基础"><a href="#命令基础" class="headerlink" title="命令基础"></a>命令基础</h3><p>Linux命令是严格区分大小写的，<br>登录后会显示一个Shell提示符，普通用户的提示符是$，root用户的提示符是#；<br>查看日期时间：date<br>队列：可以一次提交多条命令，命令之间用分号（;）隔开，Linux会依次执行<br>清屏：clear<br>强制换行：先输入反斜杠（\）再回车<br>输出：echo“ ”<br>查找文件：find / -size +50M（表示在根目录查找文件大小为大于50M的文件）<br>命令置于后台：命令后加一个&amp;</p><h4 id="文件目录类命令"><a href="#文件目录类命令" class="headerlink" title="文件目录类命令"></a>文件目录类命令</h4><p>列出某个目录下文件的信息：ls （-l长格式输出）（-a显示隐藏文件）（–help获取该命令的帮助）</p><h3 id="文件目录命令1"><a href="#文件目录命令1" class="headerlink" title="文件目录命令1"></a>文件目录命令1</h3><p>列出当前工作路径的命令：pwd<br>改变工作路径：cd（..访问父目录；.当前目录）<br>显示文本文件的内容：cat（适用于查看小文件）<br>输出重定向（在其他文件中查看制定目录）：文件名 &gt; 文件名（如果不存在自动创建，已经存在则会覆盖里面的内容，&gt;&gt;表示追加内容；相当于复制了一份）<br>    如果没有输入被输出文件，则会进入键盘输入制定内容，Ctrl+D提交（优点：快速创建小文件）<br>查看内容较长的文件：more +50（回车下一行，空格切一页，50行为一页，只能向下翻页）<br>查看文件：less（可以上下左右翻页，按Q键退出）<br>显示文件前若干行：head 5（前5行）<br>显示文件后若干行：tail 5（后5行）<br>创建目录：mkdir -p a/b/c（-p表示创建多层目录，abc为想要创建的目录）<br>删除空目录：rmdir（必须为空目录，与mkdir作用反之，方法相同）<br>复制文件：cp a b（必须有两个参数）<br>复制目录：cp -R a b<br>重命名文件（移动文件）：mv a b<br>i选项：执行询问（输入y回车表示确定，反之为n）<br>f选项：强制操作<br>r选项：递归<br>删除文件：rm</p><blockquote><p>注意：rm -rf /千万不要执行，尤其使用root账户，这个命令会将你的Linux系统根分区全部清空（格式化）<br>快速创建一个新文件：touch（如果后面的参数对应的文件不存在，就快速创建这个文件，如果这个文件已经存在了则把它的修改时间更新为当前的时间）<br>比较两个文件的区别：diff</p></blockquote><hr><p><strong>硬链接</strong><br>创建链接：ln（默认每个文件链接数初始为1）</p><blockquote><p>链接数：是指向磁盘上这个文件数据存储位置的逻辑上的文件名的个数<br>例如：ln b c 表示为b文件创建一个链接为c，此时b文件的链接数由1变为2，而同时多了一个c文件，c的链接数也是2<br>ln命令默认创建的是硬链接，也就是说，b和c对应磁盘上同一块空间，只是逻辑上是两个文件，但在物理磁盘上，是同一块空间<br>此时删除c，b不会有影响，但指向这个逻辑磁盘数少了一个，链接数由2变为1<br><strong>软链接</strong><br>创建链接：ln -s b c（符号链接/软链接）<br>创建后，b的链接数还是1，此时c文件是一个符号链接文件<br>c删掉后，b也不会受到影响<br>所谓符号链接，有点像Windows系统中的创建快捷方式</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux网络配置</title>
    <link href="/2020/02/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
    <url>/2020/02/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="Linux网络设置"><a href="#Linux网络设置" class="headerlink" title="Linux网络设置"></a><p align="center">Linux网络设置</p></h2><blockquote><p>在视频课中学习的<strong><em>Linux</em></strong>知识做的笔记，包括修改IP、网关、DNS、子网掩码一些指令和方法。</p><p align="right">记录人：霖雨成思</p></blockquote><h4 id="（在终端命令中）切换root（超级管理员）命令：su"><a href="#（在终端命令中）切换root（超级管理员）命令：su" class="headerlink" title="（在终端命令中）切换root（超级管理员）命令：su"></a>（在终端命令中）切换root（超级管理员）命令：<code>su</code></h4><p><img src="/2020/02/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/9.png" srcset="/img/loading.gif" alt="Alt text"></p><p>$表示是普通用户状态，#表示root状态</p><h4 id="（在终端命令中）切换终端：Alt-F1-F2-F3-F4-F5-F6"><a href="#（在终端命令中）切换终端：Alt-F1-F2-F3-F4-F5-F6" class="headerlink" title="（在终端命令中）切换终端：Alt+F1/F2/F3/F4/F5/F6"></a>（在终端命令中）切换终端：Alt+F1/F2/F3/F4/F5/F6</h4><p>每个终端可以有不同的命令，最多有六个终端</p><p>####（在终端命令中） 更改主机名：<code>hostname 修改的主机名（必须在root权限下）</code><br><img src="/2020/02/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/1.png" srcset="/img/loading.gif" alt="Alt text"></p><p>hostname单独写表示查看目前的主机名。注意这种更改只是<strong>临时生效，系统重启会恢复原来的主机名</strong>。</p><p>####（在终端命令下）查看网卡命令：<code>ifconfig</code><br><img src="/2020/02/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/2.png" srcset="/img/loading.gif" alt="Alt text"></p><p>eth0表示第一块以太网卡<br>lo表示虚拟网卡，一般用于测试</p><p>####（在终端命令下）查看所有的网卡命令（包括不活动的网卡）：<code>ifconfig -a</code><br>####（在终端命令下）关闭网卡命令：<code>ifconfig 网卡名称 down （ifdown 网卡名称）</code><br>####（在终端命令下）启用网卡命令：<code>ifconfig 网卡名称 up（ifup 网卡名称）</code><br>####（在终端命令下）更改网卡IP地址命令：<code>ifconfig 网卡名称 更改的IP 网关地址 子网掩码（临时生效）</code><br>不写网关地址和子网掩码则不修改<br>####（在终端命令下）修改网卡的硬件地址【MAC地址（先关闭网卡）】命令：<code>ifconfig 网卡名称 hw ether 新地址（临时生效）</code><br>####（在终端命令下）查看本机的路由表命令：<code>route</code><br>####（在终端命令下）添加网关命令：<code>route add default gw 网关地址（删除则把add换成del）</code></p><h4 id="永久修改主机名：修改-etc-sysconfig-network文件的HOSTNAME属性"><a href="#永久修改主机名：修改-etc-sysconfig-network文件的HOSTNAME属性" class="headerlink" title="永久修改主机名：修改/etc/sysconfig/network文件的HOSTNAME属性"></a>永久修改主机名：修改/etc/sysconfig/network文件的HOSTNAME属性</h4><h4 id="永久修改网卡、IP地址相关的配置文件：修改-etc-sysconfig-network-scripts-ifcfg-eth0-网卡名"><a href="#永久修改网卡、IP地址相关的配置文件：修改-etc-sysconfig-network-scripts-ifcfg-eth0-网卡名" class="headerlink" title="永久修改网卡、IP地址相关的配置文件：修改/etc/sysconfig/network-scripts/ifcfg-eth0(网卡名)"></a>永久修改网卡、IP地址相关的配置文件：修改/etc/sysconfig/network-scripts/ifcfg-eth0(网卡名)</h4><p><img src="/2020/02/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/8.png" srcset="/img/loading.gif" alt="Alt text"></p><p>其中ONBOOT为no的话<strong>网络开机默认不会自动连接</strong><br>BOOTPROTO默认是dhcp，意思是自动分配IP地址、子网掩码、网关这些信息，如果需要自己手动配置的话，我们需要把这个地方修改为null，然后在下边配置IP地址、子网掩码、网关这些信息<br>####DNS配置文件位置：/etc/resolv.conf<br><img src="/2020/02/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/3.png" srcset="/img/loading.gif" alt="Alt text"></p><h4 id="这里需要注意的是，网络相关的配置文件修改之后，需要重启网络服务才能生效。当然，重启系统也是可以的"><a href="#这里需要注意的是，网络相关的配置文件修改之后，需要重启网络服务才能生效。当然，重启系统也是可以的" class="headerlink" title="这里需要注意的是，网络相关的配置文件修改之后，需要重启网络服务才能生效。当然，重启系统也是可以的"></a>这里需要注意的是，网络相关的配置文件修改之后，需要重启网络服务才能生效。当然，重启系统也是可以的</h4><h4 id="字符界面下修改网络配置也是可以的，使用setup命令，会启动一个配置向导"><a href="#字符界面下修改网络配置也是可以的，使用setup命令，会启动一个配置向导" class="headerlink" title="字符界面下修改网络配置也是可以的，使用setup命令，会启动一个配置向导"></a>字符界面下修改网络配置也是可以的，使用setup命令，会启动一个配置向导</h4><p><img src="/2020/02/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/4.png" srcset="/img/loading.gif" alt="Alt text"></p><hr><p><img src="/2020/02/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/7.png" srcset="/img/loading.gif" alt="Alt text"></p><hr><p><img src="/2020/02/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/5.png" srcset="/img/loading.gif" alt="Alt text"></p><hr><p><img src="/2020/02/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/6.png" srcset="/img/loading.gif" alt="Alt text"></p><h4 id="重启网络服务的命令：service-network-restart"><a href="#重启网络服务的命令：service-network-restart" class="headerlink" title="重启网络服务的命令：service network restart"></a>重启网络服务的命令：<code>service network restart</code></h4><p>这就是修改网络配置的一些常用方法，可以使用命令、配置文件和使用setup向导进行修改，其中setup向导方式和修改配置文件一样都是需要重启网络服务后永久生效的。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo博客搭建</title>
    <link href="/2020/02/28/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <url>/2020/02/28/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="hexo博客搭建"><a href="#hexo博客搭建" class="headerlink" title="hexo博客搭建"></a><p align="center">hexo博客搭建</p></h2><blockquote><p>想说一下这篇博客完全是实战操作，无任何理论。搜索了很多博客，才把自己的博客软件hexo安装完成，就算是做一个笔记吧。<strong>（本篇只讲述了通过hexo搭建博客传到github中去，并更改主题的经历，并不包含域名和云服务器的故事）</strong></p></blockquote><h3 id="首先准备的材料"><a href="#首先准备的材料" class="headerlink" title="首先准备的材料"></a>首先准备的材料</h3><ul><li>Git安装包</li><li>Node.js安装包</li><li>github账户</li></ul><p>接着讲一下这三个材料都怎么获取</p><h4 id="1-Git安装包官方下载地址-https-cdn-npm-taobao-org-dist-git-for-windows-v2-25-0-windows-1-Git-2-25-0-64-bit-exe"><a href="#1-Git安装包官方下载地址-https-cdn-npm-taobao-org-dist-git-for-windows-v2-25-0-windows-1-Git-2-25-0-64-bit-exe" class="headerlink" title="1. Git安装包官方下载地址 https://cdn.npm.taobao.org/dist/git-for-windows/v2.25.0.windows.1/Git-2.25.0-64-bit.exe"></a>1. Git安装包官方下载地址 <a href="https://cdn.npm.taobao.org/dist/git-for-windows/v2.25.0.windows.1/Git-2.25.0-64-bit.exe" target="_blank" rel="noopener">https://cdn.npm.taobao.org/dist/git-for-windows/v2.25.0.windows.1/Git-2.25.0-64-bit.exe</a></h4><p>下载之后安装就可以了，我安装的时候在<strong>Adjusting your PATH environment下，勾选了Use Git from Git Bash only</strong>（默认是第二个选项，我选择了第一个），接下来全点next就可以了，直到安装完成。</p><h4 id="2-Node-js安装包官方下载地址-https-nodejs-org-dist-v12-16-1-node-v12-16-1-x64-msi"><a href="#2-Node-js安装包官方下载地址-https-nodejs-org-dist-v12-16-1-node-v12-16-1-x64-msi" class="headerlink" title="2. Node.js安装包官方下载地址 https://nodejs.org/dist/v12.16.1/node-v12.16.1-x64.msi"></a>2. Node.js安装包官方下载地址 <a href="https://nodejs.org/dist/v12.16.1/node-v12.16.1-x64.msi" target="_blank" rel="noopener">https://nodejs.org/dist/v12.16.1/node-v12.16.1-x64.msi</a></h4><p>同样，下载之后安装，我的电脑安装之后不可以再进行安装了，如果安装过程中有任何问题，可以百度查询。</p><h4 id="3-github账户"><a href="#3-github账户" class="headerlink" title="3. github账户"></a>3. github账户</h4><p>谷歌登录github官网，进行注册就可以了。这里有个坑被我踩到了，因为我在进入这个官网的过程中，实在是“挤”不进去，这个的解决办法是：***在自己电脑Windows/System32/dribers/etc目录中，找到hosts文件进入编辑，最下方输入<br># Github start<br>192.30.253.112 github.com<br>192.30.253.119 gist.github.com<br>151.101.100.133 assets-cdn.github.com<br>151.101.100.133 raw.githubusercontent.com<br>151.101.100.133 gist.githubusercontent.com<br>151.101.100.133 cloud.githubusercontent.com<br>151.101.100.133 camo.githubusercontent.com<br>151.101.100.133 avatars0.githubusercontent.com<br>151.101.100.133 avatars1.githubusercontent.com<br>151.101.100.133 avatars2.githubusercontent.com<br>151.101.100.133 avatars3.githubusercontent.com<br>151.101.100.133 avatars4.githubusercontent.com<br>151.101.100.133 avatars5.githubusercontent.com<br>151.101.100.133 avatars6.githubusercontent.com<br>151.101.100.133 avatars7.githubusercontent.com<br>151.101.100.133 avatars8.githubusercontent.com<br>192.30.253.113 github.com<br>192.30.253.113 github.com<br>192.30.253.118 gist.github.com<br>192.30.253.119 gist.github.com<br># Github end<br>就可以了，这里想说一下，最好用谷歌浏览器，因为我在许多地方发现，谷歌浏览器进入特别快。</p><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><h4 id="1-首先在一个位置新建一个空文件夹，名字任意，点进去右键选择Git-Bash-Here（如果没有则是Git安装失败）"><a href="#1-首先在一个位置新建一个空文件夹，名字任意，点进去右键选择Git-Bash-Here（如果没有则是Git安装失败）" class="headerlink" title="1. 首先在一个位置新建一个空文件夹，名字任意，点进去右键选择Git Bash Here（如果没有则是Git安装失败）"></a>1. 首先在一个位置新建一个空文件夹，名字任意，点进去右键选择Git Bash Here（如果没有则是Git安装失败）</h4><h4 id="2-安装hexo的命令："><a href="#2-安装hexo的命令：" class="headerlink" title="2.安装hexo的命令："></a>2.安装hexo的命令：</h4><pre><code>npm install -g hexo-cli</code></pre><p>这一步会很慢很慢。。。再次弹出$ 就可能表示已经成功了，输入hexo -v进行检查，弹出这个就表示成功了</p><pre><code>$ hexo -vhexo: 3.4.2hexo-cli: 1.0.4os: Windows_NT 6.1.7601 win32 x64http_parser: 2.7.0node: 8.9.1v8: 6.1.534.47uv: 1.15.0zlib: 1.2.11ares: 1.10.1-DEVmodules: 57nghttp2: 1.25.0openssl: 1.0.2micu: 59.1unicode: 9.0cldr: 31.0.1tz: 2017b</code></pre><p>继续输入hexo init来初始化hexo，注意，这个是分四次输入的</p><pre><code>hexo inithexo installnpm install hexo-deployer-git --save</code></pre><p>初始化之后，会有一个默认主题和文章，也就是我们的博客</p><pre><code>hexo server //可以简写成hexo s(这是注释)</code></pre><p>这个时候就可以通过浏览器浏览本机端口号4000的默认博客啦！(这里有些细节不一样是因为我后改了一些)。Ctrl+C可以结束</p><p><img src="/2020/02/28/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/4.png" srcset="/img/loading.gif" alt="Alt text"></p><p>我们在先暂时不更改默认博客文章的前提下，把本地文章发布到网上，让更多的人看到，这个时候就需要Github账户了<br>下面安装图片提示创建库<br>之前推荐谷歌浏览器，有一部分因为翻译成简体中文比较方便<br><img src="/2020/02/28/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/3.png" srcset="/img/loading.gif" alt="Alt text"></p><hr><p>接着创建新的库名<br><img src="/2020/02/28/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/POS.png" srcset="/img/loading.gif" alt="Alt text"></p><hr><p>这个地方注意，名称一定是你的github用户名.github.io，之前我因为打错一个字母，结果。。。坑炸了</p><p><img src="/2020/02/28/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/1.png" srcset="/img/loading.gif" alt="Alt text"></p><hr><p>创建好了之后，如下图，库里是空的，复制箭头指向的地址<br><img src="/2020/02/28/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/2.png" srcset="/img/loading.gif" alt="Alt text"></p><hr><p>然后回到自己建的文件夹中找到_config.yml进入编辑，拉到最下边，改成下图所示，并保存</p><pre><code>deploy:  type: git  repo: //刚才自己复制的地址粘贴到这里  branch: master</code></pre><p>然后再到Git Bash中输入hexo g 将本地的博客文章上传到github中去</p><pre><code>hexo d</code></pre><p>等待完成后，浏览器输入<strong>你的githubID.github.io</strong>回车，就会看到上帝的微笑了^_^</p><p>这样，就不止自己能看到了，别人输入上边的地址搜索，也能看到自己的博客。<strong>每当在本地修改一次，就重新部署上传一次</strong>，重新部署主题也是，和上边代码一样，但我一般都先清空缓存一次（分两次输入）</p><pre><code>hexo cleanhexo d</code></pre><h3 id="如何更换主题和发布文章"><a href="#如何更换主题和发布文章" class="headerlink" title="如何更换主题和发布文章"></a>如何更换主题和发布文章</h3><h4 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h4><p>hexo官网上有很多漂亮帅气的主题，每个主题也有部署方法和讲解，我举一个例子：<br>进入hexo官网之后，点击主题<br><img src="/2020/02/28/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%7DGWDEUB%7D~8ZO~PBVU5XL_6M.png" srcset="/img/loading.gif" alt="Alt text"></p><hr><p>之后选择一个自己喜欢的主题点进去<br><img src="/2020/02/28/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/0BVIN8APMA%7DHF2SA8Z0BJN.png" srcset="/img/loading.gif" alt="Alt text"></p><hr><p>里面就有详细的部署方法，比较常见的几步差不多就是</p><ul><li>下载资源，放到themes文件夹中</li><li>将_config.yml文件中的theme后的默认主题landscape更换成新下载的主题</li><li>hexo clean、hexo d清除缓存后发布</li></ul><p>当然，具体操作步骤还是参考主题发布者（官方）的说明书<br>更换完主题hexo clean和hexo s 在本地看一看，然后就可以hexo d发布到github中去了，主题也就随之更换</p><h4 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h4><p>发布文章的话，就在博客文件夹中的sourse文件夹下的_posts下，创建.md文件（markdown语言的文件，可以百度搜索一下），目前没有创建任何文章的情况下，一定会只有一个hello-world.md的文档，可以把这个文档中的开头三行复制过来，把title改一下就行了。因为- - -这种格式会被收录到目录中去。在下边就可以大刀阔斧的编写自己行编写的博客了！编写好了之后保存，在GitBash中同上，hexo clean 和hexo d两条命令发布到github中去。具体markdown语言请参考网上学习资料或视频学习，自认为还是很简单的。<br>我的服务器和域名搭建参考的wang2000博客是<a href="https://www.cnblogs.com/luqwer/p/11328600.html" target="_blank" rel="noopener">https://www.cnblogs.com/luqwer/p/11328600.html</a> 还是很有帮助的。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>我的第一篇博客文章</title>
    <link href="/2020/02/27/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"/>
    <url>/2020/02/27/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/02/26/hello-world/"/>
    <url>/2020/02/26/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
